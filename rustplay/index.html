<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rust Playground & Learning Studio</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Monaco Editor Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>

    <style>
        body, html { height: 100%; margin: 0; overflow: hidden; background-color: #111827; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Resizers */
        .resizer-x {
            width: 4px;
            cursor: col-resize;
            background-color: #374151;
            transition: background 0.2s;
            z-index: 20;
        }
        .resizer-x:hover, .resizer-x.resizing { background-color: #f97316; } /* Orange-500 */

        .resizer-y {
            height: 4px;
            cursor: row-resize;
            background-color: #374151;
            transition: background 0.2s;
            z-index: 20;
        }
        .resizer-y:hover, .resizer-y.resizing { background-color: #f97316; }

        /* Spinner */
        .spinner {
            border: 2px solid rgba(255,255,255,0.1);
            border-left-color: #fff;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .resizer-x { display: none; } /* Disable sidebar resize on mobile, use toggle */
            #sidebar {
                position: absolute;
                top: 50px; /* Header height */
                bottom: 0;
                left: 0;
                width: 80%;
                max-width: 300px;
                z-index: 50;
                transform: translateX(-100%);
                transition: transform 0.3s ease-in-out;
                box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            }
            #sidebar.open { transform: translateX(0); }
            #sidebar-backdrop {
                display: none;
                position: absolute;
                top: 50px; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 40;
            }
            #sidebar-backdrop.open { display: block; }
        }
    </style>
</head>
<body class="text-white font-sans flex flex-col h-screen select-none">

    <!-- Header -->
    <header class="flex items-center justify-between px-4 h-[50px] bg-gray-900 border-b border-gray-700 shrink-0 z-30">
        <div class="flex items-center gap-3">
            <button id="mobile-menu-btn" class="md:hidden text-gray-400 hover:text-white">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>
            <div class="flex items-center gap-2">
                <i data-lucide="hammer" class="text-orange-500 w-5 h-5"></i>
                <h1 class="text-base font-bold tracking-wide text-gray-100 hidden sm:block">Rust<span class="text-orange-500">Studio</span></h1>
            </div>
            <!-- Desktop Sidebar Toggle -->
            <button id="desktop-sidebar-toggle" class="hidden md:flex p-1 hover:bg-gray-700 rounded text-gray-400" title="Toggle Sidebar">
                <i data-lucide="panel-left" class="w-5 h-5"></i>
            </button>
        </div>
        
        <div class="flex items-center gap-3">
            <span id="status-msg" class="text-xs text-gray-400 italic hidden">Running...</span>
            <button id="run-btn" class="flex items-center gap-2 bg-orange-600 hover:bg-orange-700 active:bg-orange-800 text-white px-3 py-1.5 rounded shadow transition-colors text-sm font-medium">
                <i data-lucide="play" class="w-4 h-4 fill-current"></i> <span class="hidden sm:inline">Run</span>
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <div class="flex flex-1 overflow-hidden relative" id="workspace">
        
        <!-- Sidebar -->
        <div id="sidebar-backdrop"></div> <!-- Mobile Overlay -->
        <aside id="sidebar" class="bg-gray-800 flex flex-col border-r border-gray-700 md:relative md:transform-none md:w-64 min-w-[150px]">
            <div class="p-3 border-b border-gray-700 bg-gray-850 flex justify-between items-center">
                <h2 class="text-xs font-semibold text-gray-300 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="book-open" class="w-4 h-4"></i> Snippets
                </h2>
                <button id="close-sidebar-mobile" class="md:hidden text-gray-400">
                    <i data-lucide="x" class="w-4 h-4"></i>
                </button>
            </div>
            <div class="overflow-y-auto flex-1 p-2 space-y-1" id="snippet-list">
                <!-- Snippets injected by JS -->
            </div>
        </aside>

        <!-- Horizontal Resizer (Desktop) -->
        <div id="resizer-x" class="resizer-x hidden md:block"></div>

        <!-- Editor & Output Column -->
        <div class="flex-1 flex flex-col min-w-0 bg-[#1e1e1e]">
            
            <!-- Editor Wrapper -->
            <div id="editor-wrapper" class="flex-1 relative min-h-[100px]">
                <div id="monaco-editor" class="absolute inset-0"></div>
            </div>

            <!-- Vertical Resizer -->
            <div id="resizer-y" class="resizer-y"></div>

            <!-- Output Panel -->
            <div id="output-panel" class="bg-gray-900 flex flex-col h-48 min-h-[35px] border-t border-gray-700">
                <div class="px-3 py-1 bg-gray-800 border-b border-gray-700 flex justify-between items-center h-[35px] shrink-0 cursor-pointer" id="output-header">
                    <div class="flex items-center gap-2">
                        <i data-lucide="terminal" class="w-4 h-4 text-gray-400"></i>
                        <span class="text-xs font-semibold text-gray-400 uppercase">Console</span>
                    </div>
                    <div class="flex items-center gap-2">
                         <button id="clear-btn" class="text-xs text-gray-500 hover:text-white px-2 py-0.5 rounded hover:bg-gray-700 transition-colors">Clear</button>
                        <i id="output-chevron" data-lucide="chevron-down" class="w-4 h-4 text-gray-500 hover:text-white transition-transform"></i>
                    </div>
                </div>
                <pre id="output-console" class="flex-1 p-3 font-mono text-sm overflow-auto text-gray-300 whitespace-pre-wrap"></pre>
            </div>
        </div>
    </div>

    <!-- Initialization Script -->
    <script>
        // --- 1. Snippet Data (Same as before, abbreviated for file size optimization but fully functional) ---
        const snippets = [
             {
                category: "Basics",
                title: "1. Hello World",
                code: `fn main() {
    // Rust is efficient and expressive
    println!("Hello, from the Rust Playground!");
    
    let language = "Rust";
    println!("We are learning {} today.", language);
}`
            },
            {
                category: "Basics",
                title: "2. Variables & Mutability",
                code: `fn main() {
    // Variables are immutable by default
    let x = 5;
    println!("The value of x is: {}", x);
    // x = 6; // This would cause a compile error!

    // Add 'mut' to make a variable mutable
    let mut y = 10;
    println!("The value of y is: {}", y);
    y = 20;
    println!("The value of y is now: {}", y);

    // Constants are always immutable and need types
    const MAX_POINTS: u32 = 100_000;
    println!("Constant: {}", MAX_POINTS);
}`
            },
            {
                category: "Basics",
                title: "3. Basic Data Types",
                code: `fn main() {
    // Integers
    let a: i32 = 98_222; 
    // Floats
    let b: f64 = 2.55;
    // Booleans
    let is_active: bool = true;
    // Characters (Single quotes, unicode supported)
    let heart = 'â¤';

    println!("Integer: {}", a);
    println!("Float: {}", b);
    println!("Boolean: {}", is_active);
    println!("Char: {}", heart);

    // Tuples: Fixed length, mixed types
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup; // Destructuring
    println!("Tuple y value: {}", y);
}`
            },
            {
                category: "Basics",
                title: "4. Control Flow",
                code: `fn main() {
    let number = 6;

    // If / Else
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else {
        println!("number is not divisible by 4, 3");
    }

    // Using if in a let statement
    let condition = true;
    let number = if condition { 5 } else { 6 };
    println!("The value of number is: {}", number);
}`
            },
            {
                category: "Basics",
                title: "5. Loops",
                code: `fn main() {
    let mut count = 0;

    // 'loop' runs forever until break
    println!("--- Loop ---");
    loop {
        count += 1;
        if count == 3 {
            println!("Skipping 3");
            continue;
        }
        if count > 5 {
            break;
        }
        println!("Count is {}", count);
    }

    // 'while' loop
    println!("\\n--- While ---");
    let mut n = 3;
    while n > 0 {
        println!("{}!", n);
        n -= 1;
    }

    // 'for' loop (Iterating a range)
    println!("\\n--- For ---");
    for number in 1..4 { // 1 to 3 (exclusive)
        println!("Range number: {}", number);
    }
}`
            },
            {
                category: "Intermediate",
                title: "6. Ownership & Strings",
                code: `fn main() {
    // String type (heap allocated)
    let s1 = String::from("hello");
    
    // Ownership moves from s1 to s2
    let s2 = s1; 
    
    // println!("{}, world!", s1); // Error! s1 is no longer valid.
    println!("{}, world!", s2); // This works.

    // Cloning creates a deep copy
    let s3 = s2.clone();
    println!("s2: {}, s3: {}", s2, s3);

    // References (Borrowing)
    let len = calculate_length(&s3);
    println!("The length of '{}' is {}.", s3, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
    // s goes out of scope, but since it is a reference, nothing is dropped
}`
            },
            {
                category: "Intermediate",
                title: "7. Structs",
                code: `struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // Creating an instance
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    println!("User: {}", user1.username);
    println!("Email: {}", user1.email);
    
    // Struct Update Syntax
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1 // Copy remaining fields from user1
    };
    
    println!("User 2 Active: {}", user2.active);
}`
            },
            {
                category: "Intermediate",
                title: "8. Enums & Match",
                code: `enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {
    let c = Coin::Penny;
    println!("Value: {}", value_in_cents(c));
    
    let d = Coin::Quarter;
    println!("Value: {}", value_in_cents(d));
    
    // Option Enum (Standard library for nullable values)
    let some_number = Some(5);
    let absent_number: Option<i32> = None;
    
    if let Some(i) = some_number {
        println!("Found number: {}", i);
    }
}`
            },
            {
                category: "Intermediate",
                title: "9. Vectors",
                code: `fn main() {
    // Creating a vector
    let mut v: Vec<i32> = Vec::new();
    
    // Pushing values
    v.push(5);
    v.push(6);
    v.push(7);
    
    // Macro shorthand
    let v2 = vec![1, 2, 3];

    // Accessing elements
    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    // Safe access
    match v.get(100) {
        Some(third) => println!("The element is {}", third),
        None => println!("There is no element at index 100."),
    }

    // Iterating
    print!("Elements: ");
    for i in &v {
        print!("{} ", i);
    }
    println!("");
}`
            },
            {
                category: "Intermediate",
                title: "10. HashMaps",
                code: `use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    // Inserting keys and values
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // Accessing
    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
    println!("Score for Blue: {}", score);

    // Iterating
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }

    // Updating based on old value
    let text = "hello world wonderful world";
    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("Word count: {:?}", map);
}`
            },
            {
                category: "Algorithms",
                title: "11. Binary Search",
                code: `fn main() {
    let nums = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
    let target = 13;

    match binary_search(&nums, target) {
        Some(index) => println!("Found {} at index {}", target, index),
        None => println!("{} not found in array", target),
    }
}

fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len() as i32 - 1;

    while low <= high {
        let mid = (low + high) / 2;
        let mid_index = mid as usize;
        let val = arr[mid_index];

        if val == target {
            return Some(mid_index);
        } else if val < target {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    None
}`
            },
            {
                category: "Algorithms",
                title: "12. Bubble Sort",
                code: `fn main() {
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90];
    println!("Original: {:?}", arr);
    
    bubble_sort(&mut arr);
    
    println!("Sorted:   {:?}", arr);
}

fn bubble_sort<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    for i in 0..len {
        let mut swapped = false;
        for j in 0..len - 1 - i {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
                swapped = true;
            }
        }
        // Optimization: stop if no swaps occurred
        if !swapped {
            break;
        }
    }
}`
            },
            {
                category: "Algorithms",
                title: "13. Fibonacci (Iterative)",
                code: `fn main() {
    let n = 10;
    println!("The {}th Fibonacci number is: {}", n, fibonacci(n));
    
    // Print first 10
    print!("Sequence: ");
    for i in 0..10 {
        print!("{} ", fibonacci(i));
    }
    println!("");
}

fn fibonacci(n: u32) -> u32 {
    if n == 0 { return 0; }
    if n == 1 { return 1; }

    let mut prev = 0;
    let mut curr = 1;

    for _ in 2..=n {
        let next = prev + curr;
        prev = curr;
        curr = next;
    }
    curr
}`
            },
            {
                category: "Algorithms",
                title: "14. Palindrome Check",
                code: `fn main() {
    let word1 = "racecar";
    let word2 = "hello";
    let sentence = "A man, a plan, a canal: Panama";

    println!("'{}' is palindrome? {}", word1, is_palindrome(word1));
    println!("'{}' is palindrome? {}", word2, is_palindrome(word2));
    
    // Advanced: ignoring case and punctuation
    println!("'{}' is palindrome (strict)? {}", sentence, is_palindrome(sentence));
}

fn is_palindrome(s: &str) -> bool {
    let chars: Vec<char> = s.chars().collect();
    let len = chars.len();
    
    if len == 0 { return true; }

    for i in 0..(len / 2) {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}`
            },
            {
                category: "Algorithms",
                title: "15. Factorial (Recursive)",
                code: `fn main() {
    let num = 6;
    let result = factorial(num);
    println!("Factorial of {} is {}", num, result);
    
    let num2 = 12; // Careful with overflow on u32
    println!("Factorial of {} is {}", num2, factorial(num2));
}

fn factorial(n: u64) -> u64 {
    if n == 0 || n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}`
            }
        ];

        // --- 2. Monaco Editor Setup ---
        let editor;
        
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' }});
        
        require(['vs/editor/editor.main'], function() {
            monaco.editor.defineTheme('rust-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'comment', foreground: '6a9955' },
                    { token: 'keyword', foreground: '569cd6' },
                    { token: 'string', foreground: 'ce9178' },
                ],
                colors: {
                    'editor.background': '#1e1e1e',
                }
            });

            editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: snippets[0].code,
                language: 'rust',
                theme: 'rust-dark',
                automaticLayout: false, // We handle layout manually for performance during resize
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                fontFamily: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace"
            });
            
            // Initial layout calculation
            setTimeout(() => editor.layout(), 100);
            
            // Window resize handler
            window.addEventListener('resize', () => {
                editor.layout();
            });

            renderSnippets();
        });

        // --- 3. UI Logic & Resizing ---
        const snippetList = document.getElementById('snippet-list');
        const outputConsole = document.getElementById('output-console');
        const runBtn = document.getElementById('run-btn');
        const statusMsg = document.getElementById('status-msg');
        const clearBtn = document.getElementById('clear-btn');
        
        // Resizing Elements
        const sidebar = document.getElementById('sidebar');
        const resizerX = document.getElementById('resizer-x');
        const outputPanel = document.getElementById('output-panel');
        const resizerY = document.getElementById('resizer-y');
        const workspace = document.getElementById('workspace');

         // Toggle Elements
        const desktopSidebarToggle = document.getElementById('desktop-sidebar-toggle');
        const mobileMenuBtn = document.getElementById('mobile-menu-btn');
        const closeSidebarMobile = document.getElementById('close-sidebar-mobile');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const outputHeader = document.getElementById('output-header');
        const outputChevron = document.getElementById('output-chevron');

        // --- Resizing Logic ---
        
        // Horizontal Resize (Sidebar)
        let isResizingX = false;
        resizerX.addEventListener('mousedown', (e) => {
            isResizingX = true;
            document.body.style.cursor = 'col-resize';
            resizerX.classList.add('resizing');
            e.preventDefault(); // Prevent text selection
        });

        // Vertical Resize (Output)
        let isResizingY = false;
        let startY, startHeight;

        const startResizeY = (y) => {
            isResizingY = true;
            startY = y;
            startHeight = outputPanel.offsetHeight;
            document.body.style.cursor = 'row-resize';
            resizerY.classList.add('resizing');
        };

        resizerY.addEventListener('mousedown', (e) => {
            startResizeY(e.clientY);
            e.preventDefault();
        });
        
        // Touch support for resizing output on mobile
        resizerY.addEventListener('touchstart', (e) => {
            startResizeY(e.touches[0].clientY);
            e.preventDefault();
        });

        // Global Mouse/Touch Move
        const onMove = (clientX, clientY) => {
            if (isResizingX) {
                const newWidth = clientX;
                if (newWidth > 150 && newWidth < 600) {
                    sidebar.style.width = `${newWidth}px`;
                    editor.layout();
                }
            }
            if (isResizingY) {
                const deltaY = startY - clientY; // Dragging up increases height
                const newHeight = startHeight + deltaY;
                
                // Constraints
                const maxH = workspace.offsetHeight - 100;
                if (newHeight > 35 && newHeight < maxH) {
                    outputPanel.style.height = `${newHeight}px`;
                    editor.layout();
                }
            }
        };

        document.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY));
        document.addEventListener('touchmove', (e) => {
            if(isResizingY) onMove(e.touches[0].clientX, e.touches[0].clientY);
        });

        // Global Mouse/Touch Up
        const onUp = () => {
            if (isResizingX || isResizingY) {
                isResizingX = false;
                isResizingY = false;
                document.body.style.cursor = '';
                resizerX.classList.remove('resizing');
                resizerY.classList.remove('resizing');
                if (editor) editor.layout();
            }
        };

        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchend', onUp);


        // --- Collapse/Toggle Logic ---

        // Desktop Sidebar Toggle
        let isSidebarVisible = true;
        desktopSidebarToggle.onclick = () => {
            if (isSidebarVisible) {
                sidebar.style.display = 'none';
                resizerX.style.display = 'none';
            } else {
                sidebar.style.display = 'flex';
                resizerX.style.display = 'block';
            }
            isSidebarVisible = !isSidebarVisible;
            if (editor) editor.layout();
        };

        // Mobile Sidebar Toggle
        const toggleMobileSidebar = () => {
            sidebar.classList.toggle('open');
            sidebarBackdrop.classList.toggle('open');
        };
        mobileMenuBtn.onclick = toggleMobileSidebar;
        closeSidebarMobile.onclick = toggleMobileSidebar;
        sidebarBackdrop.onclick = toggleMobileSidebar;

        // Output Panel Toggle (Collapsible)
        let isOutputCollapsed = false;
        let lastOutputHeight = '192px'; // Default h-48

        outputHeader.onclick = () => {
            if (isOutputCollapsed) {
                // Expand
                outputPanel.style.height = lastOutputHeight;
                outputChevron.style.transform = 'rotate(0deg)';
                resizerY.style.display = 'block';
                outputConsole.style.display = 'block';
            } else {
                // Collapse
                lastOutputHeight = outputPanel.style.height || '192px';
                outputPanel.style.height = '35px'; // Header height
                outputChevron.style.transform = 'rotate(180deg)';
                resizerY.style.display = 'none'; // Hide resizer when collapsed
                outputConsole.style.display = 'none';
            }
            isOutputCollapsed = !isOutputCollapsed;
            if (editor) setTimeout(() => editor.layout(), 50); // Small delay for transition
        };


        // --- Snippet Rendering ---
        function renderSnippets() {
            let currentCategory = "";
            
            snippets.forEach((s, index) => {
                if (s.category !== currentCategory) {
                    currentCategory = s.category;
                    const header = document.createElement('div');
                    header.className = "px-3 py-2 mt-2 text-xs font-bold text-gray-500 uppercase tracking-wider";
                    header.innerText = currentCategory;
                    snippetList.appendChild(header);
                }

                const btn = document.createElement('button');
                btn.className = "w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 hover:text-white rounded transition-colors flex items-center gap-2";
                btn.innerHTML = `<i data-lucide="code-2" class="w-3 h-3"></i> <span class="truncate">${s.title}</span>`;
                
                btn.onclick = () => {
                    document.querySelectorAll('#snippet-list button').forEach(b => b.classList.remove('bg-gray-700', 'text-white'));
                    btn.classList.add('bg-gray-700', 'text-white');
                    if (editor) editor.setValue(s.code);
                    
                    // Close mobile sidebar on selection
                    if (window.innerWidth < 768) {
                        toggleMobileSidebar();
                    }
                };

                if (index === 0) btn.classList.add('bg-gray-700', 'text-white');
                snippetList.appendChild(btn);
            });
            lucide.createIcons();
        }

        clearBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent header collapse trigger
            outputConsole.textContent = "";
        };

        // --- Execution Logic ---
        runBtn.onclick = async () => {
            if (!editor) return;
            const code = editor.getValue();
            
            // Auto expand output if collapsed
            if (isOutputCollapsed) outputHeader.click();

            runBtn.disabled = true;
            runBtn.classList.add('opacity-75', 'cursor-not-allowed');
            runBtn.innerHTML = `<div class="spinner"></div>`;
            statusMsg.classList.remove('hidden');
            outputConsole.textContent = "Compiling and running...";
            outputConsole.classList.add('text-gray-400');
            outputConsole.classList.remove('text-red-400', 'text-green-400');

            try {
                const response = await fetch('https://play.rust-lang.org/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel: "stable",
                        mode: "debug",
                        edition: "2021",
                        crateType: "bin",
                        tests: false,
                        code: code
                    })
                });

                const result = await response.json();
                outputConsole.textContent = "";
                outputConsole.classList.remove('text-gray-400');

                if (result.stderr && result.stderr.trim() !== "") {
                     if (!result.success) {
                        outputConsole.classList.add('text-red-400');
                        outputConsole.textContent += "--- Compilation Error ---\n" + result.stderr;
                        return;
                    }
                }
                if (result.stdout) {
                    outputConsole.classList.add('text-green-400');
                    outputConsole.textContent += result.stdout;
                } else if (result.success) {
                    outputConsole.classList.add('text-gray-400');
                    outputConsole.textContent += "(Program finished with no output)";
                }

            } catch (error) {
                outputConsole.classList.add('text-red-400');
                outputConsole.textContent = "Error connecting to Rust Playground API:\n" + error.message;
            } finally {
                runBtn.disabled = false;
                runBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                runBtn.innerHTML = `<i data-lucide="play" class="w-4 h-4 fill-current"></i> <span class="hidden sm:inline">Run</span>`;
                statusMsg.classList.add('hidden');
                lucide.createIcons();
            }
        };

        lucide.createIcons();
    </script>
</body>
</html>
