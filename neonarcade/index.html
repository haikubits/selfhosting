<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Defender</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #fff;
            text-shadow: 0 0 10px #fff;
            font-size: 24px;
            font-weight: bold;
        }

        #score-display span {
            color: #0ff;
        }

        #lives-display span {
            color: #f0f;
        }

        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            opacity: 1;
            z-index: 10;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            color: #0ff;
            font-size: 60px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            text-align: center;
            line-height: 1;
        }

        h2 {
            color: #fff;
            font-size: 30px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #fff;
        }

        .btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 24px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.2s;
            margin-top: 20px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
        }

        .controls-hint {
            margin-top: 30px;
            color: #888;
            font-size: 14px;
            text-align: center;
            line-height: 1.5;
        }

        .mobile-controls {
            display: none; /* Shown via JS detection */
            margin-top: 10px;
            color: #aaa;
        }

        /* Powerup floating text */
        .floating-text {
            position: absolute;
            color: #ffff00;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 0 5px #ff0;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        @media (max-width: 600px) {
            h1 { font-size: 40px; }
            .hud { font-size: 18px; padding: 15px; }
            .btn { padding: 12px 30px; font-size: 20px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div id="score-display">SCORE: <span id="scoreVal">0</span></div>
            <div id="lives-display">LIVES: <span id="livesVal">3</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>Neon<br>Defender</h1>
        <button class="btn" onclick="startGame()">Start Mission</button>
        <div class="controls-hint">
            <p class="desktop-controls">Arrows / WASD to Move<br>SPACE to Shoot</p>
            <p class="mobile-controls">Touch & Drag to Move<br>Auto-fire enabled on touch</p>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #f0f; text-shadow: 0 0 20px #f0f;">GAME OVER</h1>
        <h2>Score: <span id="final-score">0</span></h2>
        <button class="btn" onclick="resetGame()">Retry</button>
    </div>

    <script>
        /**
         * NEON DEFENDER
         * A single-file HTML5 Canvas Arcade Shooter
         */

        // --- Configuration ---
        const config = {
            playerSpeed: 7,
            bulletSpeed: 10,
            enemyBaseSpeed: 2,
            spawnRate: 60, // frames between spawns
            particleLife: 30,
            colors: {
                player: '#0ff',
                bullet: '#ff0',
                enemy1: '#f0f', // Pink
                enemy2: '#f00', // Red
                enemy3: '#0f0', // Green
                particle: '#fff'
            }
        };

        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let animationId;
        let lastTime = 0;
        let frames = 0;
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let isPlaying = false;
        let isMobile = false;

        // Entities
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];

        // Input State
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false,
            ' ': false
        };
        
        const touchInput = {
            active: false,
            x: 0,
            y: 0
        };

        // --- Audio System (Synthesized) ---
        // Using AudioContext to generate retro sound effects without external files
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.3);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        }

        // --- Resize Handling ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Re-initialize stars on resize
            initStars();
            
            if(player) {
                player.y = height - 100; // Keep player near bottom
            }
        }

        window.addEventListener('resize', resize);
        
        // Check for mobile
        if ('ontouchstart' in window) {
            isMobile = true;
            document.querySelector('.desktop-controls').style.display = 'none';
            document.querySelector('.mobile-controls').style.display = 'block';
        }

        // --- Input Listeners ---
        window.addEventListener('keydown', e => {
            if(keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                // Prevent default scrolling or button activation
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            }
            if(e.key === ' ' && isPlaying && !isGameOver) {
                player.shoot();
            }
        });
        
        window.addEventListener('keyup', e => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
        });

        // Touch Logic
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchInput.active = true;
            touchInput.x = e.touches[0].clientX;
            touchInput.y = e.touches[0].clientY;
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (isPlaying && !isGameOver) {
                touchInput.x = e.touches[0].clientX;
                touchInput.y = e.touches[0].clientY;
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            touchInput.active = false;
        }, {passive: false});


        // --- Game Classes ---

        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 3 + 0.5;
                this.brightness = Math.random();
            }
            update() {
                this.y += this.speed;
                if (this.y > height) {
                    this.y = 0;
                    this.x = Math.random() * width;
                }
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Player {
            constructor() {
                this.w = 40;
                this.h = 40;
                this.x = width / 2;
                this.y = height - 100;
                this.color = config.colors.player;
                this.lastShot = 0;
                this.shootDelay = 15; // frames
            }

            update() {
                // Keyboard Movement
                if (keys.ArrowLeft || keys.a) this.x -= config.playerSpeed;
                if (keys.ArrowRight || keys.d) this.x += config.playerSpeed;
                
                // Touch Movement (Follow finger X, smooth lerp)
                if (touchInput.active) {
                    const dx = touchInput.x - this.x;
                    this.x += dx * 0.15; // Smooth follow
                    
                    // Auto fire on mobile
                    if (isMobile && frames % 10 === 0) {
                        this.shoot();
                    }
                }

                // Boundaries
                if (this.x < this.w/2) this.x = this.w/2;
                if (this.x > width - this.w/2) this.x = width - this.w/2;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                
                // Draw Ship (Triangle)
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -this.h/2);
                ctx.lineTo(this.w/2, this.h/2);
                ctx.lineTo(0, this.h/4); // Indent at bottom
                ctx.lineTo(-this.w/2, this.h/2);
                ctx.closePath();
                ctx.stroke();

                // Engine Flame
                if (Math.random() > 0.5) {
                    ctx.fillStyle = '#f00';
                    ctx.shadowColor = '#f00';
                    ctx.beginPath();
                    ctx.moveTo(-5, this.h/4 + 5);
                    ctx.lineTo(0, this.h/4 + 15 + Math.random() * 10);
                    ctx.lineTo(5, this.h/4 + 5);
                    ctx.fill();
                }

                ctx.restore();
            }

            shoot() {
                bullets.push(new Bullet(this.x, this.y - this.h/2));
                playSound('shoot');
            }
        }

        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = 3;
                this.color = config.colors.bullet;
                this.markedForDeletion = false;
            }

            update() {
                this.y -= config.bulletSpeed;
                if (this.y < 0) this.markedForDeletion = true;
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Enemy {
            constructor() {
                this.r = 20 + Math.random() * 15;
                this.x = Math.random() * (width - this.r*2) + this.r;
                this.y = -this.r - 10;
                this.speedY = config.enemyBaseSpeed + Math.random() * 2 + (score / 5000); // Get harder over time
                
                // Slight sine wave movement for some
                this.wobble = Math.random() > 0.5;
                this.wobbleOffset = Math.random() * 100;
                this.wobbleSpeed = 0.05;
                
                this.markedForDeletion = false;
                
                // Type determination
                const rand = Math.random();
                if (rand < 0.2) {
                    this.type = 2; // Tanky
                    this.hp = 3;
                    this.color = config.colors.enemy2;
                    this.scoreValue = 300;
                } else if (rand < 0.5) {
                    this.type = 3; // Fast
                    this.hp = 1;
                    this.speedY *= 1.5;
                    this.color = config.colors.enemy3;
                    this.scoreValue = 200;
                } else {
                    this.type = 1; // Normal
                    this.hp = 1;
                    this.color = config.colors.enemy1;
                    this.scoreValue = 100;
                }
            }

            update() {
                this.y += this.speedY;
                
                if (this.wobble) {
                    this.x += Math.sin(this.y * 0.02 + this.wobbleOffset) * 2;
                }

                // Bounds checking
                if (this.x < this.r) this.x = this.r;
                if (this.x > width - this.r) this.x = width - this.r;

                if (this.y > height + this.r) {
                    this.markedForDeletion = true;
                    // Penalty for missing enemies? Maybe in a stricter mode.
                }
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.translate(this.x, this.y);
                ctx.rotate(frames * 0.05);

                ctx.beginPath();
                if (this.type === 1) {
                    // Square
                    ctx.rect(-this.r, -this.r, this.r*2, this.r*2);
                } else if (this.type === 2) {
                    // Diamond/Octagon
                    const s = this.r;
                    ctx.moveTo(s, 0); ctx.lineTo(0, s); ctx.lineTo(-s, 0); ctx.lineTo(0, -s);
                    ctx.lineTo(s/2, -s/2); // Detail
                } else {
                    // Triangle (Fast)
                    ctx.moveTo(0, this.r);
                    ctx.lineTo(this.r, -this.r);
                    ctx.lineTo(-this.r, -this.r);
                }
                ctx.closePath();
                ctx.stroke();

                // Inner detail
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.fill();

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = config.particleLife;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.size *= 0.95;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / config.particleLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- Core Functions ---

        function initStars() {
            stars = [];
            for(let i = 0; i < 100; i++) {
                stars.push(new Star());
            }
        }

        function createExplosion(x, y, color) {
            for(let i = 0; i < 15; i++) {
                particles.push(new Particle(x, y, color));
            }
            playSound('explosion');
        }

        function showFloatingText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.innerText = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function startGame() {
            // Remove focus from button to prevent Space key from triggering it again
            if (document.activeElement) document.activeElement.blur();

            document.getElementById('start-screen').classList.add('hidden');
            resetGameInternal();
            isPlaying = true;
            isGameOver = false;
            // Resume audio context if browser suspended it
            if(audioCtx.state === 'suspended') audioCtx.resume();
            gameLoop();
        }

        function resetGame() {
            // Remove focus from button
            if (document.activeElement) document.activeElement.blur();

            document.getElementById('game-over-screen').classList.add('hidden');
            resetGameInternal();
            isPlaying = true;
            isGameOver = false;
        }

        function resetGameInternal() {
            score = 0;
            lives = 3;
            frames = 0;
            enemies = [];
            bullets = [];
            particles = [];
            player = new Player();
            updateUI();
        }

        function updateUI() {
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('livesVal').innerText = 'â™¥'.repeat(lives);
        }

        function gameOver() {
            isGameOver = true;
            isPlaying = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        // --- Game Loop ---

        function gameLoop() {
            if (!isPlaying && !isGameOver) return; // Paused or not started
            
            // Clear
            ctx.fillStyle = '#050510'; // Dark background
            ctx.fillRect(0, 0, width, height);

            // Update & Draw Background Stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });

            if (isGameOver) {
                // Keep drawing background animation but stop game logic
                // Maybe draw the wreckage of the player?
                particles.forEach(p => { p.update(); p.draw(); });
                requestAnimationFrame(gameLoop);
                return;
            }

            frames++;

            // Spawn Enemies
            if (frames % config.spawnRate === 0) {
                enemies.push(new Enemy());
                // Increase difficulty slightly
                if (frames % 1000 === 0 && config.spawnRate > 20) {
                    config.spawnRate -= 5;
                }
            }

            // Update Player
            player.update();
            player.draw();

            // Update Bullets
            bullets.forEach((b, index) => {
                b.update();
                b.draw();
                if (b.markedForDeletion) bullets.splice(index, 1);
            });

            // Update Enemies & Collision
            enemies.forEach((e, eIndex) => {
                e.update();
                e.draw();

                // Collision: Bullet vs Enemy
                bullets.forEach((b, bIndex) => {
                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (dist < e.r + b.r) {
                        // Hit!
                        createExplosion(e.x, e.y, e.color);
                        playSound('hit');
                        
                        b.markedForDeletion = true;
                        e.hp--;
                        
                        if (e.hp <= 0) {
                            e.markedForDeletion = true;
                            score += e.scoreValue;
                            showFloatingText(`+${e.scoreValue}`, e.x, e.y);
                        }
                    }
                });

                // Collision: Player vs Enemy
                const distPlayer = Math.hypot(player.x - e.x, player.y - e.y);
                if (distPlayer < player.w/2 + e.r) {
                    e.markedForDeletion = true;
                    createExplosion(player.x, player.y, '#0ff');
                    lives--;
                    updateUI();
                    
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        // Invulnerability frames or push back could go here
                        // For now, just clear nearby enemies
                        enemies = enemies.filter(en => Math.hypot(player.x - en.x, player.y - en.y) > 200);
                    }
                }
            });

            // Cleanup
            bullets = bullets.filter(b => !b.markedForDeletion);
            enemies = enemies.filter(e => !e.markedForDeletion);
            
            // Update Particles
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(index, 1);
            });

            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        resize();
        initStars();
        
        // Initial draw just to show background
        function attractLoop() {
            if(!isPlaying) {
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, width, height);
                stars.forEach(star => {
                    star.update();
                    star.draw();
                });
                requestAnimationFrame(attractLoop);
            }
        }
        attractLoop();

    </script>
</body>
</html>
