<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>PDF Editor Pro</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- PDF-Lib -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        body {
            background-color: #f3f4f6;
            /* Allow default touch actions (scroll/zoom) on body */
            overscroll-behavior: none; 
        }

        /* --- Workspace & Pages --- */
        #workspace {
            overflow-y: auto;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 120px; /* Space for floating toolbar */
        }
        
        .page-container {
            position: relative;
            background-color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin: 0 auto 24px auto;
            /* Default to blocking touch only when drawing class is active */
            touch-action: auto; 
        }

        /* When drawing, disable browser handling of gestures on the page */
        .page-container.drawing-active {
            touch-action: none;
        }

        canvas {
            display: block;
        }

        .interaction-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* --- Text Elements --- */
        .text-layer {
            position: absolute;
            inset: 0;
            overflow: hidden;
            z-index: 20;
            pointer-events: none;
        }
        
        .text-element {
            position: absolute;
            font-family: sans-serif;
            font-size: 16px;
            color: black;
            padding: 4px;
            border: 1px dashed transparent;
            pointer-events: auto;
            white-space: pre-wrap;
            line-height: 1;
            /* Better touch targets */
            min-width: 40px; 
            min-height: 40px;
        }
        .text-element:hover, .text-element:active {
            border-color: #3b82f6;
            background-color: rgba(255, 255, 255, 0.8);
        }
        .text-element:focus {
            outline: none;
            border-color: #2563eb;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* --- Floating Toolbar --- */
        .floating-toolbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 16px;
            border-radius: 9999px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            max-width: 95vw;
            overflow-x: auto;
        }

        .tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 12px;
            color: #4b5563;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .tool-btn i {
            font-size: 24px;
            margin-bottom: 2px;
        }
        
        .tool-btn span {
            font-size: 10px;
            font-weight: 500;
        }

        .tool-btn.active {
            background-color: #eff6ff;
            color: #2563eb;
        }
        
        .tool-btn:active {
            transform: scale(0.95);
        }

        /* Preview Mode */
        .preview-mode .interaction-layer, 
        .preview-mode .text-layer { display: none; }
        
        .disabled { opacity: 0.5; pointer-events: none; }

        /* Hide scrollbar on toolbar */
        .floating-toolbar::-webkit-scrollbar { display: none; }

        /* Media Queries for Desktop layout tweaks */
        @media (min-width: 768px) {
            .floating-toolbar {
                top: 80px; /* Below header */
                bottom: auto;
                padding: 6px 12px;
                border-radius: 16px;
            }
            .tool-btn {
                width: 44px;
                height: 44px;
            }
        }
    </style>
</head>
<body class="h-screen flex flex-col text-gray-800 font-sans">

    <!-- Navbar -->
    <header class="bg-white border-b border-gray-200 h-16 flex items-center justify-between px-4 z-40 shrink-0 sticky top-0 shadow-sm">
        <div class="flex items-center gap-2">
            <i class="ph-fill ph-file-pdf text-red-500 text-3xl"></i>
            <h1 class="font-bold text-lg leading-tight hidden sm:block">PDF Editor</h1>
        </div>

        <div class="flex items-center gap-2 sm:gap-3">
            <!-- File Upload -->
            <label class="cursor-pointer bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2">
                <i class="ph-bold ph-upload-simple text-lg"></i>
                <span class="hidden sm:inline">Upload</span>
                <input type="file" id="file-upload" accept="application/pdf" class="hidden">
            </label>

            <!-- Preview Toggle -->
            <button id="btn-preview" disabled class="disabled bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2">
                <i class="ph-bold ph-eye text-lg"></i>
                <span class="hidden sm:inline">Preview</span>
            </button>

            <!-- Download -->
            <button id="btn-download" disabled class="disabled bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2 shadow-sm">
                <i class="ph-bold ph-download-simple text-lg"></i>
                <span class="hidden sm:inline">Save</span>
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <main id="workspace" class="flex-1 w-full bg-gray-100 relative">
        
        <!-- Empty State -->
        <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 p-6 text-center">
            <div class="bg-white p-6 rounded-full shadow-sm mb-4">
                <i class="ph-duotone ph-file-pdf text-6xl text-blue-500"></i>
            </div>
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Upload a PDF to Edit</h2>
            <p class="text-sm max-w-xs mx-auto">Tap "Upload" to select a document. Sign, draw, or add text.</p>
        </div>

        <!-- Pages Container -->
        <div id="pages-container" class="hidden flex flex-col items-center pt-6 px-2 sm:px-6">
            <!-- Pages injected here -->
        </div>

    </main>

    <!-- Floating Tools (Bottom on Mobile, Top-Floating on Desktop) -->
    <div id="tools-bar" class="floating-toolbar hidden">
        <button id="btn-hand" class="tool-btn active" title="Hand / Navigate">
            <i class="ph-bold ph-hand-grabbing"></i>
            <span>Move</span>
        </button>
        <div class="w-px h-8 bg-gray-200 mx-1"></div>
        <button id="btn-draw" class="tool-btn" title="Pen Tool">
            <i class="ph-bold ph-pen-nib"></i>
            <span>Draw</span>
        </button>
        <button id="btn-whiteout" class="tool-btn" title="Whiteout">
            <i class="ph-bold ph-eraser"></i>
            <span>Erase</span>
        </button>
        <button id="btn-text" class="tool-btn" title="Text Tool">
            <i class="ph-bold ph-text-t"></i>
            <span>Text</span>
        </button>
        <div class="w-px h-8 bg-gray-200 mx-1"></div>
        <button id="btn-undo" class="tool-btn text-gray-500" title="Undo">
            <i class="ph-bold ph-arrow-u-up-left"></i>
            <span>Undo</span>
        </button>
    </div>

    <!-- Status Toast (Optional) -->
    <div id="toast" class="fixed top-20 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full text-sm opacity-0 transition pointer-events-none z-50">
        Action Saved
    </div>

    <script>
        // --- State ---
        const state = {
            currentPdfBytes: null,
            previewPdfBytes: null,
            totalPages: 0,
            
            // Adjust scale based on device width for better mobile fit
            scale: window.innerWidth < 768 ? 0.6 : 1.2, 
            
            tool: 'hand', // hand, draw, whiteout, text
            activePage: 0,
            isDrawing: false,
            isPreview: false,
            edits: {} // { [pageNum]: { paths: [], rects: [], texts: [] } }
        };

        // --- Refs ---
        const els = {
            fileInput: document.getElementById('file-upload'),
            pagesContainer: document.getElementById('pages-container'),
            emptyState: document.getElementById('empty-state'),
            toolsBar: document.getElementById('tools-bar'),
            btnDownload: document.getElementById('btn-download'),
            btnPreview: document.getElementById('btn-preview'),
            toast: document.getElementById('toast'),
            tools: {
                hand: document.getElementById('btn-hand'),
                draw: document.getElementById('btn-draw'),
                whiteout: document.getElementById('btn-whiteout'),
                text: document.getElementById('btn-text'),
                undo: document.getElementById('btn-undo')
            }
        };

        let currentPath = [];
        let currentRect = null;
        let activeDragId = null;
        let dragOffset = { x: 0, y: 0 };
        let draggedPageNum = 0;

        // --- Init ---
        els.fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') return alert('PDF only!');

            // Loading State
            els.emptyState.innerHTML = '<div class="animate-spin text-4xl text-blue-500"><i class="ph-bold ph-circle-notch"></i></div><p class="mt-4 text-gray-600">Loading PDF...</p>';

            try {
                const arrayBuffer = await file.arrayBuffer();
                state.currentPdfBytes = arrayBuffer;
                
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                state.totalPages = pdfDoc.getPageCount();

                // Reset
                state.isPreview = false;
                state.edits = {};
                for (let i = 1; i <= state.totalPages; i++) {
                    state.edits[i] = { paths: [], rects: [], texts: [] };
                }

                els.emptyState.classList.add('hidden');
                els.pagesContainer.classList.remove('hidden');
                els.toolsBar.classList.remove('hidden');
                els.btnDownload.disabled = false;
                els.btnPreview.disabled = false;
                els.btnDownload.classList.remove('disabled');
                els.btnPreview.classList.remove('disabled');

                await renderAllPages();
                showToast(`Loaded ${state.totalPages} pages`);
            } catch (err) {
                console.error(err);
                els.emptyState.innerHTML = '<p class="text-red-500">Error loading PDF</p>';
            }
        });

        // --- Render ---
        async function renderAllPages() {
            els.pagesContainer.innerHTML = '';
            const bytes = state.isPreview ? state.previewPdfBytes : state.currentPdfBytes;
            if (!bytes) return;

            const loadingTask = pdfjsLib.getDocument({ data: bytes.slice(0) });
            const pdf = await loadingTask.promise;

            for (let i = 1; i <= state.totalPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: state.scale });

                // Wrapper
                const div = document.createElement('div');
                div.className = 'page-container';
                div.dataset.page = i;
                if (state.tool === 'draw' || state.tool === 'whiteout') {
                    div.classList.add('drawing-active');
                }
                div.style.width = `${viewport.width}px`;
                div.style.height = `${viewport.height}px`;

                // Canvas (PDF)
                const canvasPdf = document.createElement('canvas');
                canvasPdf.width = viewport.width;
                canvasPdf.height = viewport.height;
                await page.render({ canvasContext: canvasPdf.getContext('2d'), viewport }).promise;

                // Canvas (Interaction)
                const canvasInteract = document.createElement('canvas');
                canvasInteract.className = 'interaction-layer';
                canvasInteract.width = viewport.width;
                canvasInteract.height = viewport.height;

                // Div (Text)
                const divText = document.createElement('div');
                divText.className = 'text-layer';

                div.appendChild(canvasPdf);
                div.appendChild(canvasInteract);
                div.appendChild(divText);
                els.pagesContainer.appendChild(div);

                if (!state.isPreview) {
                    redrawCanvas(i, canvasInteract);
                    renderTexts(i, divText);
                }
            }
        }

        // --- Tools ---
        Object.keys(els.tools).forEach(k => {
            if(k === 'undo') return;
            els.tools[k].addEventListener('click', () => setTool(k));
        });

        els.tools.undo.addEventListener('click', undoLast);

        function setTool(t) {
            state.tool = t;
            // UI
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            els.tools[t].classList.add('active');

            // Touch Action logic:
            // If Hand/Text -> user can scroll (touch-action: auto)
            // If Draw/Eraser -> user draws (touch-action: none on pages)
            const pages = document.querySelectorAll('.page-container');
            pages.forEach(p => {
                if (t === 'draw' || t === 'whiteout') {
                    p.classList.add('drawing-active');
                    p.querySelector('.interaction-layer').style.cursor = 'crosshair';
                } else {
                    p.classList.remove('drawing-active');
                    p.querySelector('.interaction-layer').style.cursor = t === 'text' ? 'text' : 'default';
                }
            });

            showToast(`Tool: ${t.charAt(0).toUpperCase() + t.slice(1)}`);
        }

        function showToast(msg) {
            els.toast.textContent = msg;
            els.toast.classList.remove('opacity-0');
            setTimeout(() => els.toast.classList.add('opacity-0'), 2000);
        }

        // --- Interaction Logic (Delegated) ---
        // We use pointer events for unified mouse/touch handling where possible, 
        // but need specific touch logic for canvas drawing vs scrolling.

        const container = els.pagesContainer;

        // 1. POINTER DOWN
        container.addEventListener('pointerdown', (e) => {
            if (state.isPreview) return;
            
            const target = e.target;
            // Check if hitting interaction layer
            if (!target.classList.contains('interaction-layer')) return;

            const pageDiv = target.closest('.page-container');
            const pageNum = parseInt(pageDiv.dataset.page);
            state.activePage = pageNum;

            const rect = target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // TEXT TOOL: Create text immediately
            if (state.tool === 'text') {
                e.preventDefault(); // Stop potential emulated mouse clicks
                const id = Date.now().toString();
                state.edits[pageNum].texts.push({ id, x, y: y - 10, text: 'Text' });
                renderTexts(pageNum, pageDiv.querySelector('.text-layer'));
                
                // Focus newly created text
                setTimeout(() => {
                    const el = document.getElementById(`txt-${id}`);
                    if(el) {
                        el.focus();
                        // select all
                        const range = document.createRange();
                        range.selectNodeContents(el);
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }, 50);
                
                setTool('hand'); // Auto switch back to hand for panning
                return;
            }

            // DRAW / WHITEOUT
            if (state.tool === 'draw' || state.tool === 'whiteout') {
                // Prevent scrolling via touch-action css, but also ensure capture
                target.setPointerCapture(e.pointerId);
                state.isDrawing = true;
                
                if (state.tool === 'draw') {
                    currentPath = [{ x, y }];
                } else {
                    currentRect = { x, y, w: 0, h: 0 };
                }
            }
        });

        // 2. POINTER MOVE
        container.addEventListener('pointermove', (e) => {
            if (!state.isDrawing) return;
            if (state.isPreview) return;

            const target = e.target;
            if (!target.classList.contains('interaction-layer')) return;
            
            const rect = target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const ctx = target.getContext('2d');

            if (state.tool === 'draw') {
                // simple smoothing could go here, but raw lineTo is fast
                const prev = currentPath[currentPath.length - 1];
                currentPath.push({ x, y });
                
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(x, y);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = '#000000';
                ctx.stroke();
            } 
            else if (state.tool === 'whiteout') {
                currentRect.w = x - currentRect.x;
                currentRect.h = y - currentRect.y;
                redrawCanvas(state.activePage, target); // clear & redraw existing + preview
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(currentRect.x, currentRect.y, currentRect.w, currentRect.h);
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.w, currentRect.h);
            }
        });

        // 3. POINTER UP
        container.addEventListener('pointerup', (e) => {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            
            const target = e.target;
            if (target.classList.contains('interaction-layer')) {
                 target.releasePointerCapture(e.pointerId);
            }

            const pIdx = state.activePage;
            
            if (state.tool === 'draw' && currentPath.length > 1) {
                state.edits[pIdx].paths.push([...currentPath]);
            } 
            else if (state.tool === 'whiteout' && currentRect) {
                // Normalize rect
                if (currentRect.w < 0) { currentRect.x += currentRect.w; currentRect.w = Math.abs(currentRect.w); }
                if (currentRect.h < 0) { currentRect.y += currentRect.h; currentRect.h = Math.abs(currentRect.h); }
                if (currentRect.w > 2 && currentRect.h > 2) {
                    state.edits[pIdx].rects.push({...currentRect});
                }
                // Redraw to remove the gray preview and show whiteout
                const pageDiv = document.querySelector(`.page-container[data-page="${pIdx}"]`);
                if(pageDiv) redrawCanvas(pIdx, pageDiv.querySelector('.interaction-layer'));
            }
            
            currentPath = [];
            currentRect = null;
        });


        // --- Drawing Helpers ---
        function redrawCanvas(pageNum, canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const data = state.edits[pageNum];

            // 1. Whiteouts
            ctx.fillStyle = '#ffffff';
            data.rects.forEach(r => ctx.fillRect(r.x, r.y, r.w, r.h));

            // 2. Paths
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            
            ctx.beginPath();
            data.paths.forEach(path => {
                if(path.length < 2) return;
                ctx.moveTo(path[0].x, path[0].y);
                for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            });
            ctx.stroke();
        }

        // --- Text Handling ---
        function renderTexts(pageNum, container) {
            container.innerHTML = '';
            state.edits[pageNum].texts.forEach(t => {
                const el = document.createElement('div');
                el.id = `txt-${t.id}`;
                el.className = 'text-element';
                el.contentEditable = true;
                el.innerText = t.text;
                el.style.left = `${t.x}px`;
                el.style.top = `${t.y}px`;

                // Drag Start
                el.addEventListener('pointerdown', (e) => {
                    if (state.tool !== 'hand') return; // Only move in hand mode
                    e.stopPropagation(); // Don't trigger page tools
                    
                    activeDragId = t.id;
                    draggedPageNum = pageNum;
                    const r = el.getBoundingClientRect();
                    dragOffset = { x: e.clientX - r.left, y: e.clientY - r.top };
                    el.setPointerCapture(e.pointerId);
                });

                // Drag Move
                el.addEventListener('pointermove', (e) => {
                    if (activeDragId !== t.id) return;
                    e.preventDefault();
                    
                    // We need coordinates relative to the text-layer
                    const parentRect = container.getBoundingClientRect();
                    const newX = e.clientX - parentRect.left - dragOffset.x;
                    const newY = e.clientY - parentRect.top - dragOffset.y;
                    
                    el.style.left = `${newX}px`;
                    el.style.top = `${newY}px`;
                    t.x = newX;
                    t.y = newY;
                });

                // Drag End
                el.addEventListener('pointerup', (e) => {
                    if(activeDragId === t.id) {
                        el.releasePointerCapture(e.pointerId);
                        activeDragId = null;
                    }
                });

                // Edit Content
                el.addEventListener('blur', () => {
                    t.text = el.innerText;
                    if (!t.text.trim()) {
                        // Remove empty
                        state.edits[pageNum].texts = state.edits[pageNum].texts.filter(x => x.id !== t.id);
                        renderTexts(pageNum, container);
                    }
                });

                container.appendChild(el);
            });
        }

        function undoLast() {
            if (!state.activePage || state.activePage < 1) return showToast('Tap a page first');
            const d = state.edits[state.activePage];
            
            // Simple logic: remove from whichever array is non-empty, checking order loosely
            if (d.paths.length > 0) d.paths.pop();
            else if (d.rects.length > 0) d.rects.pop();
            else if (d.texts.length > 0) d.texts.pop();
            else return showToast('Nothing to undo');

            const pageDiv = document.querySelector(`.page-container[data-page="${state.activePage}"]`);
            if (pageDiv) {
                redrawCanvas(state.activePage, pageDiv.querySelector('.interaction-layer'));
                renderTexts(state.activePage, pageDiv.querySelector('.text-layer'));
            }
            showToast('Undone');
        }


        // --- Save / Preview ---
        els.btnPreview.addEventListener('click', async () => {
            if (state.isPreview) {
                state.isPreview = false;
                state.previewPdfBytes = null;
                els.btnPreview.innerHTML = '<i class="ph-bold ph-eye text-lg"></i><span class="hidden sm:inline">Preview</span>';
                els.toolsBar.classList.remove('hidden');
                await renderAllPages();
            } else {
                showToast('Generating Preview...');
                state.previewPdfBytes = await generatePdf();
                state.isPreview = true;
                els.btnPreview.innerHTML = '<i class="ph-bold ph-pencil-simple text-lg"></i><span class="hidden sm:inline">Edit</span>';
                els.toolsBar.classList.add('hidden');
                await renderAllPages();
                document.querySelectorAll('.page-container').forEach(p => p.classList.add('preview-mode'));
            }
        });

        els.btnDownload.addEventListener('click', async () => {
            showToast('Preparing Download...');
            const bytes = await generatePdf();
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `edited_${Date.now()}.pdf`;
            link.click();
            showToast('Download Started');
        });

        async function generatePdf() {
            // Load original
            const pdfDoc = await PDFLib.PDFDocument.load(state.currentPdfBytes.slice(0));
            const pdfJsDoc = await pdfjsLib.getDocument({ data: state.currentPdfBytes.slice(0) }).promise;
            const pages = pdfDoc.getPages();

            for (let i = 1; i <= state.totalPages; i++) {
                const data = state.edits[i];
                if (!data.paths.length && !data.rects.length && !data.texts.length) continue;

                const page = pages[i - 1];
                const pageH = page.getHeight();
                
                // Calc scale factor based on how we rendered it on screen vs actual PDF size
                const pageViewport = await pdfJsDoc.getPage(i).then(p => p.getViewport({ scale: state.scale }));
                const scaleX = page.getWidth() / pageViewport.width;
                const scaleY = page.getHeight() / pageViewport.height;

                // 1. Whiteouts
                data.rects.forEach(r => {
                    page.drawRectangle({
                        x: r.x * scaleX,
                        y: pageH - ((r.y + r.h) * scaleY),
                        width: r.w * scaleX,
                        height: r.h * scaleY,
                        color: PDFLib.rgb(1, 1, 1)
                    });
                });

                // 2. Paths
                data.paths.forEach(p => {
                    // Convert screen coords to PDF coords
                    // Remember PDF coords are Bottom-Left origin
                    const pdfPath = p.map(pt => ({
                        x: pt.x * scaleX,
                        y: pageH - (pt.y * scaleY)
                    }));

                    for(let k=0; k<pdfPath.length-1; k++) {
                        page.drawLine({
                            start: pdfPath[k],
                            end: pdfPath[k+1],
                            thickness: 2,
                            color: PDFLib.rgb(0,0,0)
                        });
                    }
                });

                // 3. Texts
                data.texts.forEach(t => {
                    // Visual adjustment for font baseline
                    // On screen, (x,y) is top-left of box. In PDF, drawText (x,y) is baseline.
                    // 16px font ~ 12pt in PDF? We scale explicitly.
                    
                    const fontSize = 16 * scaleY; 
                    // Move down by ~fontSize to match top-left vs baseline visual difference
                    const adjustedY = t.y + (16 * 0.8); 
                    
                    page.drawText(t.text, {
                        x: t.x * scaleX,
                        y: pageH - (adjustedY * scaleY),
                        size: fontSize,
                        color: PDFLib.rgb(0,0,0)
                    });
                });
            }
            return await pdfDoc.save();
        }
    </script>
</body>
</html>
