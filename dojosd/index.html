<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dojo Showdown: Debug Mode</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #game-container {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 4px solid #333;
            border-radius: 4px;
            position: relative;
        }
        .controls-overlay {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            opacity: 0.7;
            font-size: 14px;
        }
        .debug-log {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #0f0;
            background: rgba(0,0,0,0.8);
            padding: 5px;
            pointer-events: none;
            max-height: 100px;
            overflow: hidden;
            width: 300px;
        }
        .debug-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            font-size: 12px;
            z-index: 100;
            transition: all 0.2s;
        }
        .debug-btn:hover {
            background: #0f0;
            color: #000;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

<div id="game-container">
    <div id="debug-console" class="debug-log">System Ready...</div>
    <button id="debug-toggle" class="debug-btn">DEBUG: ON</button>
</div>
<div class="controls-overlay">
    P1: Arrows to Move • Z to Punch • X to Kick | R to Restart
</div>

<script>
// --- UTILS ---
function log(msg) {
    const el = document.getElementById('debug-console');
    if (el) {
        el.innerHTML = `> ${msg}<br>` + el.innerHTML;
    }
    console.log(`[GAME] ${msg}`);
}

/**
 * AUDIO SYNTHESIZER
 */
class GameAudio {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol = 0.1) {
        this.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playPunch() {
        this.resume();
        const bufferSize = this.ctx.sampleRate * 0.1; 
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        noise.start();
        this.playTone(150, 'square', 0.1, 0.1);
    }

    playWhiff() {
        this.playTone(400, 'sine', 0.1, 0.05);
    }

    playJump() {
        this.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }
}

const audio = new GameAudio();

const CONFIG = {
    width: 800,
    height: 450,
    gravity: 1200,
    speed: 300,
    jump: -750
};

/**
 * TEXTURE GENERATOR
 */
class TextureGenerator {
    static createTextures(scene) {
        // Background
        const bgCanvas = scene.make.graphics({ width: 800, height: 450 });
        bgCanvas.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xF4A460, 0xF4A460, 1);
        bgCanvas.fillRect(0, 0, 800, 450);
        bgCanvas.fillStyle(0x556B2F, 1);
        bgCanvas.beginPath();
        bgCanvas.moveTo(0, 450); bgCanvas.lineTo(150, 200); bgCanvas.lineTo(300, 450); bgCanvas.lineTo(500, 150); bgCanvas.lineTo(800, 450);
        bgCanvas.fill();
        bgCanvas.generateTexture('sky', 800, 450);

        // Floor
        const floor = scene.make.graphics({ x: 0, y: 0, add: false });
        floor.fillStyle(0x3d3d3d, 1); floor.fillRect(0, 0, 800, 64);
        floor.fillStyle(0x555555, 1); for(let i=0; i<800; i+=40) floor.fillRect(i, 0, 38, 64); 
        floor.generateTexture('floor', 800, 64);

        // Panda Idle
        const panda = scene.make.graphics({ x: 0, y: 0, add: false });
        panda.fillStyle(0xffffff, 1); panda.fillCircle(32, 45, 25); panda.fillCircle(32, 25, 18);
        panda.fillStyle(0x111111, 1); panda.fillCircle(22, 20, 6); panda.fillCircle(42, 20, 6); panda.fillCircle(14, 10, 8); panda.fillCircle(50, 10, 8); panda.fillEllipse(32, 35, 10, 6);
        panda.fillCircle(10, 40, 10); panda.fillCircle(54, 40, 10); panda.fillCircle(15, 70, 12); panda.fillCircle(49, 70, 12);
        panda.fillStyle(0xff0000, 1); panda.fillRect(14, 12, 36, 6);
        panda.generateTexture('panda_idle', 64, 80);

        // Panda Attack
        panda.clear();
        panda.fillStyle(0xffffff, 1); panda.fillCircle(32, 45, 25); panda.fillCircle(38, 28, 18);
        panda.fillStyle(0x111111, 1); panda.fillCircle(15, 70, 12); panda.fillCircle(55, 65, 12); panda.fillCircle(60, 40, 12);
        panda.generateTexture('panda_attack', 70, 80);

        // Tiger Idle
        const tiger = scene.make.graphics({ x: 0, y: 0, add: false });
        tiger.fillStyle(0xffa500, 1); tiger.fillCircle(32, 45, 22); tiger.fillCircle(32, 22, 16);
        tiger.fillStyle(0x000000, 1); tiger.beginPath(); tiger.moveTo(25, 10); tiger.lineTo(39, 10); tiger.lineTo(32, 25); tiger.fill();
        tiger.fillRect(15, 40, 10, 4); tiger.fillRect(39, 45, 10, 4);
        tiger.fillStyle(0xffffff, 1); tiger.fillCircle(26, 20, 4); tiger.fillCircle(38, 20, 4);
        tiger.fillStyle(0x000000, 1); tiger.fillCircle(26, 20, 2); tiger.fillCircle(38, 20, 2);
        tiger.fillStyle(0xffa500, 1); tiger.fillCircle(15, 70, 11); tiger.fillCircle(49, 70, 11);
        tiger.generateTexture('tiger_idle', 64, 80);

        // Tiger Attack
        tiger.clear();
        tiger.fillStyle(0xffa500, 1); tiger.fillCircle(32, 45, 22); tiger.fillCircle(25, 22, 16); 
        tiger.fillStyle(0x000000, 1); tiger.fillRect(15, 40, 10, 4);
        tiger.fillStyle(0xffa500, 1); tiger.fillCircle(60, 40, 12);
        tiger.generateTexture('tiger_attack', 70, 80);

        // Particle
        const p = scene.make.graphics();
        p.fillStyle(0xffffff, 1); p.fillCircle(4,4,4);
        p.generateTexture('particle', 8, 8);
    }
}

/**
 * ENTITY: FIGHTER
 */
class Fighter extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, textureKey, isPlayer) {
        super(scene, x, y, textureKey);
        scene.add.existing(this);
        scene.physics.add.existing(this);

        this.setCollideWorldBounds(true);
        this.setDragX(1000); 
        this.setBodySize(40, 70);
        this.setOffset(12, 5);

        this.isPlayer = isPlayer;
        this.hp = 100;
        this.isAttacking = false;
        this.isHurt = false;
        this.textureBase = textureKey.replace('_idle', '');
        
        // --- HITBOX SETUP ---
        // We create a physics sprite but disable gravity so it doesn't fall.
        this.attackHitbox = scene.physics.add.sprite(x, y, null);
        this.attackHitbox.setVisible(false); // Set to true to debug visually if needed
        this.attackHitbox.setSize(50, 50);
        this.attackHitbox.body.enable = false;
        this.attackHitbox.body.allowGravity = false;
        this.attackHitbox.body.immovable = true;
    }

    update(cursors, target) {
        if (this.isHurt) return;

        const onGround = this.body.touching.down;

        // PLAYER MOVEMENT
        if (this.isPlayer) {
            if (!this.isAttacking) {
                if (cursors.left.isDown) {
                    this.setVelocityX(-CONFIG.speed);
                    this.setFlipX(true);
                } else if (cursors.right.isDown) {
                    this.setVelocityX(CONFIG.speed);
                    this.setFlipX(false);
                } else {
                    this.setVelocityX(0);
                }

                if (cursors.up.isDown && onGround) {
                    this.setVelocityY(CONFIG.jump);
                    audio.playJump();
                }

                if (Phaser.Input.Keyboard.JustDown(this.scene.keyZ) || Phaser.Input.Keyboard.JustDown(this.scene.keyX)) {
                    this.attack();
                }
            }
        } 
        // AI MOVEMENT
        else {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, target.x, target.y);
            this.setFlipX(target.x < this.x);

            if (!this.isAttacking && !this.isHurt) {
                if (dist > 70) {
                    if (this.x < target.x) this.setVelocityX(CONFIG.speed * 0.6);
                    else this.setVelocityX(-CONFIG.speed * 0.6);
                } else {
                    this.setVelocityX(0);
                    if (Math.random() < 0.02) this.attack();
                }
                if (onGround && Math.random() < 0.005) this.setVelocityY(CONFIG.jump);
            }
        }

        // --- ANIMATION SWAP ---
        const desiredTexture = this.isAttacking ? `${this.textureBase}_attack` : `${this.textureBase}_idle`;
        if (this.texture.key !== desiredTexture) {
            this.setTexture(desiredTexture);
            // Re-apply body size after texture swap prevents 'shrinking' bugs
            this.setBodySize(40, 70); 
            this.setOffset(12, 5); 
        }

        // --- HITBOX SYNC (CLEANUP) ---
        // We ensure the hitbox body is zeroed out when not in use
        if (!this.isAttacking) {
            this.attackHitbox.body.velocity.set(0, 0);
            this.attackHitbox.setPosition(this.x, this.y); // visual only
        }
    }

    attack() {
        if (this.isAttacking || this.isHurt) return;
        
        this.isAttacking = true;
        this.setVelocityX(0);
        audio.playWhiff();

        const name = this.isPlayer ? "Panda" : "Tiger";
        
        // Attack Delay
        this.scene.time.delayedCall(50, () => {
            if (!this.scene) return;
            
            // --- THE FIX: FIRST PRINCIPLES POSITIONING ---
            // Calculate where the hitbox SHOULD be based on CURRENT direction
            const offset = this.flipX ? -40 : 40;
            const hitX = this.x + offset;
            const hitY = this.y;

            // Debug Log
            if (this.isPlayer) {
                log(`ATTACK! Player: ${Math.floor(this.x)}, HitboxTarget: ${Math.floor(hitX)}`);
            }

            // CRITICAL: Force Reset the Body to this location.
            // .reset() moves the body immediately and zeros velocity.
            // This fixes the "drift" where the body thinks it's at (0,0) or old coordinates.
            this.attackHitbox.body.reset(hitX, hitY);
            
            // Re-enable
            this.attackHitbox.body.enable = true;
        });

        // End Attack
        this.scene.time.delayedCall(300, () => {
            if (!this.scene) return;
            this.isAttacking = false;
            this.attackHitbox.body.enable = false;
        });
    }

    takeDamage(amount, sourceX) {
        if (this.isHurt) return;
        this.hp = Math.max(0, this.hp - amount);
        this.isHurt = true;
        this.setTint(0xff0000);
        
        const dir = this.x < sourceX ? -1 : 1;
        this.setVelocity(dir * 400, -300);
        this.scene.cameras.main.shake(100, 0.01);
        
        const name = this.isPlayer ? "Panda" : "Tiger";
        log(`${name} hit! HP: ${this.hp}`);

        this.scene.time.delayedCall(500, () => {
            if (this.scene) {
                this.isHurt = false;
                this.clearTint();
            }
        });
    }
}

/**
 * MAIN SCENE
 */
class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        TextureGenerator.createTextures(this);
    }

    create() {
        this.input.on('pointerdown', () => audio.resume());

        this.add.image(400, 225, 'sky');

        // --- DEBUG TOGGLE SETUP ---
        const debugBtn = document.getElementById('debug-toggle');
        const debugConsole = document.getElementById('debug-console');
        
        let isDebugOn = true;

        debugBtn.onclick = () => {
            isDebugOn = !isDebugOn;
            
            // Toggle Physics Debug Lines (accessing Phaser internal graphics)
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.setVisible(isDebugOn);
            }
            
            // Toggle Console Text
            debugConsole.style.display = isDebugOn ? 'block' : 'none';
            
            // Update Button Text
            debugBtn.innerText = `DEBUG: ${isDebugOn ? 'ON' : 'OFF'}`;
            debugBtn.style.color = isDebugOn ? '#0f0' : '#888';
            debugBtn.style.borderColor = isDebugOn ? '#0f0' : '#888';
        };

        this.platforms = this.physics.add.staticGroup();
        const floor = this.platforms.create(400, 450, 'floor');
        floor.setScale(1).refreshBody();

        this.cursors = this.input.keyboard.createCursorKeys();
        this.keyZ = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
        this.keyX = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
        this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);

        this.player = new Fighter(this, 200, 300, 'panda_idle', true);
        this.enemy = new Fighter(this, 600, 300, 'tiger_idle', false);
        this.enemy.setFlipX(true);

        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.enemy, this.platforms);

        this.emitter = this.add.particles(0, 0, 'particle', {
            speed: 100, scale: { start: 1, end: 0 }, lifespan: 300, blendMode: 'ADD', emitting: false
        });

        this.createUI();
        this.gameOver = false;
        this.winText = this.add.text(400, 225, '', { fontSize: '64px', fill: '#fff', stroke: '#000', strokeThickness: 6 }).setOrigin(0.5).setVisible(false);
        
        log("Game Started. Debug Mode ON.");
    }

    createUI() {
        this.add.text(20, 20, 'PANDA', { fontSize: '20px', fill: '#fff', fontStyle: 'bold' });
        this.p1HealthBg = this.add.rectangle(170, 30, 200, 20, 0x333333);
        this.p1HealthBar = this.add.rectangle(170, 30, 200, 20, 0x00ff00);

        this.add.text(720, 20, 'TIGER', { fontSize: '20px', fill: '#fff', fontStyle: 'bold' }).setOrigin(1, 0);
        this.enemyHealthBg = this.add.rectangle(630, 30, 200, 20, 0x333333);
        this.enemyHealthBar = this.add.rectangle(630, 30, 200, 20, 0xff0000);
    }

    updateUI() {
        const p1Pct = this.player.hp / 100;
        this.p1HealthBar.width = 200 * p1Pct;
        const enPct = this.enemy.hp / 100;
        this.enemyHealthBar.width = 200 * enPct;
        this.p1HealthBar.fillColor = p1Pct < 0.3 ? 0xff0000 : 0x00ff00;
    }

    checkAttacks() {
        // Player vs Enemy
        if (this.player.attackHitbox.body.enable) {
            this.physics.overlap(this.player.attackHitbox, this.enemy, () => {
                if (!this.enemy.isHurt) {
                    this.enemy.takeDamage(10, this.player.x);
                    this.createHitEffect(this.enemy.x, this.enemy.y);
                    audio.playPunch();
                    this.player.attackHitbox.body.enable = false;
                }
            });
        }

        // Enemy vs Player
        if (this.enemy.attackHitbox.body.enable) {
            this.physics.overlap(this.enemy.attackHitbox, this.player, () => {
                if (!this.player.isHurt) {
                    this.player.takeDamage(8, this.enemy.x);
                    this.createHitEffect(this.player.x, this.player.y);
                    audio.playPunch();
                    this.enemy.attackHitbox.body.enable = false;
                }
            });
        }
    }

    createHitEffect(x, y) {
        this.emitter.setPosition(x, y);
        this.emitter.explode(10);
        const circle = this.add.circle(x, y, 30, 0xffffff, 1);
        this.tweens.add({ targets: circle, scale: 2, alpha: 0, duration: 100, onComplete: () => circle.destroy() });
    }

    update() {
        if (this.gameOver) {
            if (Phaser.Input.Keyboard.JustDown(this.keyR)) this.scene.restart();
            return;
        }

        this.player.update(this.cursors, this.enemy);
        this.enemy.update(null, this.player);

        this.checkAttacks();
        this.updateUI();

        if (this.player.hp <= 0) this.endGame('TIGER WINS!');
        if (this.enemy.hp <= 0) this.endGame('PANDA WINS!');
    }

    endGame(msg) {
        this.gameOver = true;
        this.physics.pause();
        this.player.setTint(0x555555);
        this.enemy.setTint(0x555555);
        this.winText.setText(msg);
        this.winText.setVisible(true);
        this.add.text(400, 300, 'Press R to Restart', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
    }
}

const gameConfig = {
    type: Phaser.AUTO,
    width: CONFIG.width,
    height: CONFIG.height,
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: CONFIG.gravity },
            debug: true // CRITICAL DEBUG VISUALIZATION
        }
    },
    scene: MainScene
};

const game = new Phaser.Game(gameConfig);

</script>
</body>
</html>
