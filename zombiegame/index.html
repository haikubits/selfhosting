<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Zombie Protocol: Outbreak</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #00ffcc;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffcc;
        }

        .hud-bottom {
            padding: 20px;
            color: #ff3333;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 5px #ff3333;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #00ffcc;
        }
        #crosshair::before {
            top: 9px; left: 0; width: 20px; height: 2px;
        }
        #crosshair::after {
            top: 0; left: 9px; width: 2px; height: 20px;
        }

        /* Menus */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 60px;
            margin-bottom: 10px;
            color: #ff0055;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 20px #ff0055;
        }

        p { font-size: 20px; color: #ccc; max-width: 600px; text-align: center; line-height: 1.5; }

        .btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            background: transparent;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 20px #00ffcc;
        }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .hidden { display: none !important; }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">SCORE: 0</div>
            <div id="wave-display">WAVE: 1</div>
        </div>
        <div class="hud-bottom">
            <div id="health-display">HEALTH: 100%</div>
        </div>
        <div id="crosshair"></div>
    </div>

    <div id="start-screen">
        <h1>Zombie Protocol</h1>
        <p>Experimental Subject #742. Survive the outbreak.</p>
        <p style="font-size: 16px; margin-top: 10px; color: #888;">Controls: WASD to Move • Mouse to Look • Click to Shoot</p>
        <button class="btn" id="start-btn">Initialize</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>TERMINATED</h1>
        <p id="final-score">Score: 0</p>
        <button class="btn" id="restart-btn">Re-Initialize</button>
    </div>

    <script>
        // --- GAME CONFIGURATION ---
        const CONFIG = {
            playerSpeed: 15,
            playerRunSpeed: 25,
            zombieSpeed: 6,
            zombieDamage: 10,
            gravity: 30,
            jumpForce: 15,
            bulletSpeed: 100,
            fireRate: 0.15, // Seconds between shots
            colors: {
                sky: 0x050510,
                ground: 0x111115,
                fog: 0x050510,
                zombie: 0x228822,
                blood: 0xaa0000,
                muzzle: 0xffffaa
            }
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let clock, delta;
        let player = {
            height: 1.8,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            health: 100,
            score: 0,
            dead: false,
            canShoot: true
        };
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        
        // Game State
        let zombies = [];
        let bullets = [];
        let particles = [];
        let lastShotTime = 0;
        let wave = 1;
        let zombiesToSpawn = 0;
        let spawnTimer = 0;
        let gameActive = false;

        // Visuals
        let gunMesh, muzzleLight;
        
        // Audio Context (Procedural Sound)
        let audioCtx;

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('game-container');

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.02);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; // Important for FPS controls

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            scene.add(dirLight);

            // 5. Environment
            createEnvironment();

            // 6. Player Weapon
            createWeapon();

            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);

            clock = new THREE.Clock();
            
            // Loop
            renderer.setAnimationLoop(animate);
        }

        // --- ENVIRONMENT GENERATION ---
        function createEnvironment() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.ground, 
                roughness: 0.8 
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid Helper (for "digital" look)
            const grid = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
            scene.add(grid);

            // Obstacles (Random boxes)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 });
            
            for(let i=0; i<50; i++) {
                const h = Math.random() * 4 + 1;
                const obstacle = new THREE.Mesh(boxGeo, boxMat);
                obstacle.scale.set(Math.random() * 4 + 2, h, Math.random() * 4 + 2);
                
                // Keep center clear
                let x = (Math.random() - 0.5) * 150;
                let z = (Math.random() - 0.5) * 150;
                if(Math.abs(x) < 10 && Math.abs(z) < 10) x += 20;

                obstacle.position.set(x, h/2, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
            }
        }

        // --- WEAPON & PLAYER ---
        function createWeapon() {
            const gunGroup = new THREE.Group();
            
            // Gun Body
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.4);
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, -0.1, 0);
            gunGroup.add(mesh);

            // Barrel
            const barrelGeo = new THREE.BoxGeometry(0.05, 0.05, 0.4);
            const barrel = new THREE.Mesh(barrelGeo, mat);
            barrel.position.set(0, -0.05, -0.3);
            gunGroup.add(barrel);

            // Muzzle Flash Light
            muzzleLight = new THREE.PointLight(CONFIG.colors.muzzle, 0, 10);
            muzzleLight.position.set(0, 0, -0.6);
            gunGroup.add(muzzleLight);

            gunGroup.position.set(0.3, -0.3, -0.5);
            camera.add(gunGroup);
            scene.add(camera); // Add camera to scene
            gunMesh = gunGroup;
        }

        // --- GAME LOGIC ---

        function startGame() {
            // Audio Init
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            document.getElementById('start-screen').classList.add('hidden');
            document.body.requestPointerLock();
            gameActive = true;
            resetPlayer();
            resetZombies();
            wave = 1;
            updateHUD();
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            startGame();
        }

        function resetPlayer() {
            camera.position.set(0, player.height, 0);
            camera.rotation.set(0, 0, 0);
            player.health = 100;
            player.score = 0;
            player.dead = false;
            player.velocity.set(0,0,0);
        }

        function resetZombies() {
            zombies.forEach(z => scene.remove(z.mesh));
            zombies = [];
            bullets.forEach(b => scene.remove(b.mesh));
            bullets = [];
            startWave();
        }

        function startWave() {
            zombiesToSpawn = 5 + (wave * 2);
            spawnTimer = 0;
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score-display').innerText = `SCORE: ${player.score}`;
            document.getElementById('wave-display').innerText = `WAVE: ${wave}`;
            document.getElementById('health-display').innerText = `HEALTH: ${player.health}%`;
        }

        // --- CONTROLS ---
        function onKeyDown(e) {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                // case 'Space': if (canJump) player.velocity.y = CONFIG.jumpForce; canJump = false; break;
            }
        }

        function onKeyUp(e) {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseMove(e) {
            if (!gameActive || player.dead) return;
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function onMouseDown(e) {
            if (!gameActive || player.dead) return;
            if (document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
                return;
            }
            if (e.button === 0) fireWeapon(); // Left click
        }

        // --- ZOMBIE SYSTEM ---
        class Zombie {
            constructor() {
                this.mesh = new THREE.Group();
                
                // Materials
                const skinMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.zombie });
                const clothMat = new THREE.MeshStandardMaterial({ color: 0x334455 });

                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), skinMat);
                head.position.y = 1.7;
                this.mesh.add(head);

                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), clothMat);
                body.position.y = 1.15;
                this.mesh.add(body);

                // Arms
                this.leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), skinMat);
                this.leftArm.position.set(-0.35, 1.2, 0.3);
                this.leftArm.rotation.x = -Math.PI / 3; // Arms out
                this.mesh.add(this.leftArm);

                this.rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), skinMat);
                this.rightArm.position.set(0.35, 1.2, 0.3);
                this.rightArm.rotation.x = -Math.PI / 3;
                this.mesh.add(this.rightArm);

                // Spawn Logic
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 20;
                this.mesh.position.set(
                    camera.position.x + Math.cos(angle) * radius,
                    0,
                    camera.position.z + Math.sin(angle) * radius
                );

                this.mesh.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
                
                this.speed = CONFIG.zombieSpeed + (Math.random() * 2);
                this.hp = 30 + (wave * 5);
                this.id = Math.random().toString(36).substr(2, 9);
                this.walkOffset = Math.random() * 100;
                
                scene.add(this.mesh);
            }

            update(dt) {
                // Look at player
                this.mesh.lookAt(camera.position.x, 1.5, camera.position.z);
                
                // Move forward
                const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));

                // Animation
                const walkCycle = Math.sin((clock.elapsedTime * 10) + this.walkOffset);
                this.leftArm.rotation.x = -Math.PI/3 + (walkCycle * 0.1);
                this.rightArm.rotation.x = -Math.PI/3 - (walkCycle * 0.1);
                this.mesh.position.y = Math.abs(walkCycle * 0.05);
            }

            takeDamage(amount) {
                this.hp -= amount;
                playSound('hit');
                createBlood(this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
                
                // Flash Red
                this.mesh.children.forEach(c => {
                    if(c.material) {
                        c.material.emissive.setHex(0xff0000);
                        setTimeout(() => c.material.emissive.setHex(0x000000), 100);
                    }
                });

                if (this.hp <= 0) this.die();
            }

            die() {
                scene.remove(this.mesh);
                zombies = zombies.filter(z => z !== this);
                player.score += 10;
                updateHUD();
                
                // Check wave clear
                if (zombies.length === 0 && zombiesToSpawn <= 0) {
                    wave++;
                    playSound('waveComplete');
                    setTimeout(startWave, 2000);
                }
            }
        }

        // --- WEAPON SYSTEM ---
        function fireWeapon() {
            if (clock.getElapsedTime() - lastShotTime < CONFIG.fireRate) return;
            
            lastShotTime = clock.getElapsedTime();
            playSound('shoot');

            // Gun Recoil Animation
            gunMesh.position.z += 0.1;
            setTimeout(() => gunMesh.position.z -= 0.1, 100);
            
            // Muzzle Flash
            muzzleLight.intensity = 2;
            setTimeout(() => muzzleLight.intensity = 0, 50);

            // Raycast
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Create visible tracer
            const tracerGeo = new THREE.BufferGeometry().setFromPoints([
                gunMesh.parent.localToWorld(new THREE.Vector3(0.3, -0.3, -1)),
                camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100))
            ]);
            const tracer = new THREE.Line(tracerGeo, new THREE.LineBasicMaterial({ color: 0xffff00 }));
            scene.add(tracer);
            setTimeout(() => scene.remove(tracer), 50);

            // Hit Detection
            const hitObjects = [];
            zombies.forEach(z => z.mesh.children.forEach(c => hitObjects.push({mesh: c, zombie: z})));
            
            const intersects = raycaster.intersectObjects(hitObjects.map(h => h.mesh));

            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitObj = hitObjects.find(h => h.mesh === hit.object);
                if (hitObj) {
                    hitObj.zombie.takeDamage(20);
                }
            }
        }

        // --- PARTICLE SYSTEM ---
        function createBlood(pos) {
            for(let i=0; i<5; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.blood });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5) * 0.5;
                mesh.position.y += (Math.random() - 0.5) * 0.5;
                mesh.position.z += (Math.random() - 0.5) * 0.5;

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    Math.random(),
                    (Math.random() - 0.5)
                );

                particles.push({ mesh, vel, life: 1.0 });
                scene.add(mesh);
            }
        }

        // --- AUDIO SYSTEM (Procedural) ---
        function playSound(type) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'damage') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(20, now + 0.3);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'waveComplete') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(880, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent huge jumps

            if (gameActive && !player.dead) {
                // 1. Player Movement
                const speed = moveForward ? CONFIG.playerRunSpeed : (moveBackward ? CONFIG.playerSpeed * 0.6 : CONFIG.playerSpeed);
                player.velocity.x -= player.velocity.x * 10.0 * delta;
                player.velocity.z -= player.velocity.z * 10.0 * delta;
                // player.velocity.y -= CONFIG.gravity * delta; // Simple gravity

                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
                player.direction.normalize();

                if (moveForward || moveBackward) player.velocity.z -= player.direction.z * speed * delta;
                if (moveLeft || moveRight) player.velocity.x -= player.direction.x * speed * delta;

                camera.translateX(-player.velocity.x * delta);
                camera.translateZ(-player.velocity.z * delta);
                // Keep player on ground (no complex physics for floor)
                camera.position.y = player.height; 

                // Weapon Sway
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    const time = clock.elapsedTime * 10;
                    gunMesh.position.y = -0.3 + Math.sin(time) * 0.01;
                    gunMesh.position.x = 0.3 + Math.cos(time * 0.5) * 0.01;
                }

                // 2. Zombie Spawning
                if (zombiesToSpawn > 0) {
                    spawnTimer += delta;
                    if (spawnTimer > 1.0) { // Spawn every second
                        zombies.push(new Zombie());
                        zombiesToSpawn--;
                        spawnTimer = 0;
                    }
                }

                // 3. Zombie Logic
                for(let i = zombies.length - 1; i >= 0; i--) {
                    const z = zombies[i];
                    z.update(delta);
                    
                    // Collision with Player
                    const dist = z.mesh.position.distanceTo(camera.position);
                    if (dist < 1.5) {
                        player.health -= CONFIG.zombieDamage * delta * 2; // Damage over time
                        updateHUD();
                        
                        // Red Flash Overlay
                        const overlay = document.getElementById('damage-overlay');
                        overlay.style.opacity = 0.8;
                        setTimeout(() => overlay.style.opacity = 0, 100);
                        
                        playSound('damage');

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }

                // 4. Particles
                for(let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.life -= delta * 2;
                    p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                    p.vel.y -= 9.8 * delta; // Gravity
                    
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        particles.splice(i, 1);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function gameOver() {
            gameActive = false;
            player.dead = true;
            document.exitPointerLock();
            document.getElementById('final-score').innerText = `Score: ${Math.floor(player.score)} - Waves: ${wave}`;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>
