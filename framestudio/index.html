<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Framer Studio</title>
    <meta name="description" content="Browser-based photo framing studio. Privacy-first, zero-backend.">
    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #333;
            --input-bg: #2a2a2a;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            height: 60px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            justify-content: space-between;
            flex-shrink: 0;
        }

        h1 { font-size: 1.2rem; font-weight: 600; margin: 0; display: flex; align-items: center; gap: 0.5rem; }
        
        .header-controls { display: flex; gap: 1rem; align-items: center; }

        .btn {
            background-color: var(--input-bg);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }
        .btn:hover { background-color: var(--border); }
        .btn-primary { background-color: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary:hover { background-color: var(--accent-hover); }

        /* --- Recent Strip --- */
        #recent-strip {
            height: 60px;
            background-color: #181818;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            gap: 0.5rem;
            overflow-x: auto;
            flex-shrink: 0;
        }
        .recent-thumb {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
            background: #333;
        }
        .recent-thumb:hover { border-color: var(--text-muted); }

        /* --- Main Layout --- */
        main {
            flex: 1;
            display: grid;
            grid-template-columns: 260px 1fr 300px;
            overflow: hidden;
        }

        /* --- Left: Templates --- */
        .panel {
            background-color: var(--bg-panel);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            border-left: 1px solid var(--border);
        }

        .panel-header {
            padding: 1rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            background: var(--bg-panel);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            padding: 1rem;
        }

        .template-card {
            aspect-ratio: 1;
            background-color: #2a2a2a;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }
        
        .template-card.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .template-card:hover:not(.active) { border-color: #555; }

        .template-preview { flex: 1; width: 100%; height: 100%; display: block; }
        .template-name { 
            position: absolute; bottom: 0; left: 0; right: 0; 
            background: rgba(0,0,0,0.7); font-size: 0.7rem; padding: 4px; text-align: center;
        }

        /* --- Center: Canvas --- */
        .workspace {
            background-color: #0f0f0f;
            /* Chequered background for transparency */
            background-image: linear-gradient(45deg, #1a1a1a 25%, transparent 25%), linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1a1a1a 75%), linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #studio-canvas {
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 90%;
            max-height: 90%;
            cursor: grab;
        }
        #studio-canvas:active { cursor: grabbing; }

        /* --- Right: Inspector --- */
        .controls-list { padding: 1rem; display: flex; flex-direction: column; gap: 1.5rem; }

        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .control-label { font-size: 0.85rem; color: var(--text-muted); display: flex; justify-content: space-between; }
        .control-value { color: var(--text-main); font-variant-numeric: tabular-nums; }

        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 6px; background: #333; border-radius: 3px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; background: var(--text-main); border-radius: 50%; cursor: pointer;
        }

        .color-picker-wrapper {
            display: flex; align-items: center; gap: 0.5rem; background: var(--input-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);
        }
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 24px; height: 24px; padding: 0; background: none; cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }
        
        .export-section { margin-top: auto; padding: 1rem; border-top: 1px solid var(--border); display: flex; flex-direction: column; gap: 0.8rem; }

        /* --- Footer --- */
        footer {
            height: 30px; background: var(--bg-panel); border-top: 1px solid var(--border);
            display: flex; align-items: center; justify-content: center; font-size: 0.75rem; color: var(--text-muted);
        }

        /* --- Hidden Inputs --- */
        #file-input { display: none; }

        /* --- Responsive --- */
        @media (max-width: 900px) {
            main { grid-template-columns: 80px 1fr 250px; }
            .template-grid { grid-template-columns: 1fr; }
            .template-name { display: none; }
        }
        @media (max-width: 700px) {
            main { grid-template-columns: 1fr; grid-template-rows: 1fr 200px; }
            .panel.left { display: none; /* Hide template list on mobile portrait for space, maybe toggled via menu in real app */ }
            /* Simple mobile tweak: Stack inspector below */
            main { display: flex; flex-direction: column; }
            .workspace { flex: 1; min-height: 50vh; }
            .panel.right { height: 40vh; border-left: none; border-top: 1px solid var(--border); }
            /* Mobile Template Scroller */
            .panel.left { display: flex; height: 100px; flex-direction: row; order: 2; border-right: none; border-top: 1px solid var(--border); overflow-x: auto; width: 100%; }
            .template-grid { display: flex; padding: 0.5rem; width: max-content; }
            .template-card { width: 80px; height: 80px; }
            .panel.right { order: 3; }
        }

        .toast {
            position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 0.9rem; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <header>
        <h1><span style="font-size:1.4rem">üñºÔ∏è</span> Photo Framer Studio</h1>
        <div class="header-controls">
            <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">
                <span>Open Photo</span>
            </button>
            <input type="file" id="file-input" accept="image/*">
        </div>
    </header>

    <div id="recent-strip">
        <!-- Recent thumbnails injected here -->
        <span style="font-size:0.8rem; color:#666; margin-right:10px;">Recent:</span>
    </div>

    <main>
        <!-- Left Panel: Templates -->
        <div class="panel left">
            <div class="panel-header">Templates</div>
            <div class="template-grid" id="template-grid">
                <!-- Templates injected here -->
            </div>
        </div>

        <!-- Center: Workspace -->
        <div class="workspace" id="workspace">
            <canvas id="studio-canvas"></canvas>
        </div>

        <!-- Right Panel: Inspector -->
        <div class="panel right">
            <div class="panel-header">Studio Controls</div>
            <div class="controls-list">
                
                <div class="control-group">
                    <label class="control-label">Border Width <span id="val-border-w" class="control-value">24</span></label>
                    <input type="range" id="inp-border-w" min="0" max="100">
                </div>

                <div class="control-group">
                    <label class="control-label">Margin Width <span id="val-margin-w" class="control-value">40</span></label>
                    <input type="range" id="inp-margin-w" min="0" max="200">
                </div>

                <div class="control-group">
                    <label class="control-label">Border Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="inp-border-c" value="#222222">
                        <span id="txt-border-c" style="font-size:0.8rem; font-family:monospace;">#222222</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Margin Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="inp-margin-c" value="#FFFFFF">
                        <span id="txt-margin-c" style="font-size:0.8rem; font-family:monospace;">#FFFFFF</span>
                    </div>
                </div>

                <hr style="border: 0; border-top: 1px solid var(--border); width: 100%;">

                <div class="control-group">
                    <label class="control-label">Zoom Photo <span id="val-zoom" class="control-value">100%</span></label>
                    <input type="range" id="inp-zoom" min="0.1" max="4" step="0.1" value="1">
                </div>

                <div style="display:flex; gap:0.5rem;">
                    <button class="btn" style="flex:1" onclick="app.resetView()">Center</button>
                    <button class="btn" style="flex:1" onclick="app.fitView()">Fit</button>
                </div>

            </div>

            <div class="export-section">
                <button class="btn btn-primary" style="justify-content:center" onclick="app.exportImage('download')">
                    Download PNG
                </button>
                <button class="btn" style="justify-content:center" onclick="app.exportImage('clipboard')">
                    Copy to Clipboard
                </button>
                <button class="btn" style="justify-content:center" onclick="app.exportImage('jpeg')">
                    Download JPEG
                </button>
            </div>
        </div>
    </main>

    <footer>
        <span id="footer-msg">Tip: Drag photo to pan, Scroll to zoom. Shift+Arrow keys to nudge.</span>
    </footer>

    <div id="toast" class="toast">Action Complete</div>

    <script>
/**
 * PHOTO FRAMER STUDIO
 * Single-file Vanilla JS implementation
 */

// --- Constants & Templates ---
const TEMPLATES = [
    {
        id: "minimal-matte", name: "Minimal Matte", shape: "rect", cornerRadius: 0,
        defaults: { borderWidth: 16, marginWidth: 60, borderColor: "#111111", marginColor: "#FAFAFA" },
        limits: { borderWidth: [0, 60], marginWidth: [0, 160] },
        ornamentLayers: [
            { type: "stroke", placement: "margin", opacity: 1, params: { strokeStyle: "rgba(0,0,0,0.15)", lineWidth: 1 } },
            { type: "stroke", placement: "inner",  opacity: 1, params: { strokeStyle: "rgba(0,0,0,0.15)", lineWidth: 2 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 10, blur: 20, color: "rgba(0,0,0,0.25)", inner: false },
        mask: { type: "rect" }
    },
    {
        id: "art-deco-fan", name: "Art Deco", shape: "rect", cornerRadius: 6,
        defaults: { borderWidth: 20, marginWidth: 40, borderColor: "#0E0E0E", marginColor: "#F6F2E9" },
        limits: { borderWidth: [8, 80], marginWidth: [20, 140] },
        ornamentLayers: [
            { type: "svgPattern", placement: "border", opacity: 1, params: { svg: "<svg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'><path d='M0,100 L50,0 L100,100 Z' fill='none' stroke='#C6A867' stroke-width='6'/></svg>", scale: 0.6 } },
            { type: "stroke", placement: "inner", params: { strokeStyle: "#C6A867", lineWidth: 3 } }
        ],
        shadow: { enabled: false },
        mask: { type: "rounded", params: { radius: 6 } }
    },
    {
        id: "baroque-gold", name: "Baroque", shape: "rect", cornerRadius: 10,
        defaults: { borderWidth: 36, marginWidth: 24, borderColor: "#3A2A12", marginColor: "#FFFDF8" },
        limits: { borderWidth: [16, 120], marginWidth: [0, 120] },
        ornamentLayers: [
            { type: "svgPattern", placement: "border", opacity: 1, params: { svg: "<svg viewBox='0 0 120 120' xmlns='http://www.w3.org/2000/svg'><path d='M10,60q50-50,100,0q-50,50-100,0Z' fill='none' stroke='#D9B56D' stroke-width='5'/></svg>", scale: 0.8 } },
            { type: "stroke", placement: "border", params: { strokeStyle: "#D9B56D", lineWidth: 6 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 16, blur: 28, color: "rgba(0,0,0,0.3)" },
        mask: { type: "rounded", params: { radius: 10 } }
    },
    {
        id: "greek-key", name: "Greek Key", shape: "rect", cornerRadius: 0,
        defaults: { borderWidth: 28, marginWidth: 22, borderColor: "#101418", marginColor: "#FFFFFF" },
        limits: { borderWidth: [12, 100], marginWidth: [0, 120] },
        ornamentLayers: [
            { type: "svgPattern", placement: "border", params: { svg: "<svg viewBox='0 0 100 20' xmlns='http://www.w3.org/2000/svg'><path d='M0,10h40v-8h16v16H24v-8h16' fill='none' stroke='#555' stroke-width='3'/></svg>", scale: 1 } }
        ],
        shadow: { enabled: false },
        mask: { type: "rect" }
    },
    {
        id: "lace-doily", name: "Lace Oval", shape: "oval", cornerRadius: 0,
        defaults: { borderWidth: 24, marginWidth: 30, borderColor: "#f0f0f0", marginColor: "#FFF7FB" },
        limits: { borderWidth: [8, 80], marginWidth: [10, 160] },
        ornamentLayers: [
            { type: "svgPattern", placement: "border", params: { svg: "<svg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'><circle cx='50' cy='50' r='45' fill='none' stroke='#ccc' stroke-width='4' stroke-dasharray='2 6'/></svg>", scale: 1 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 8, blur: 18, color: "rgba(0,0,0,0.2)" },
        mask: { type: "oval" }
    },
    {
        id: "rustic-wood", name: "Rustic Wood", shape: "rect", cornerRadius: 8,
        defaults: { borderWidth: 40, marginWidth: 16, borderColor: "#6B3F1A", marginColor: "#FAF6EE" },
        limits: { borderWidth: [20, 140], marginWidth: [0, 100] },
        ornamentLayers: [
            { type: "texture", placement: "border", params: { svg: "<svg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'><path d='M0,50 q25-20 50,0 t50,0' fill='none' stroke='#442211' stroke-width='1' opacity='0.3'/></svg>", scale: 1 } },
            { type: "stroke", placement: "inner", params: { strokeStyle: "rgba(46, 26, 12, 0.6)", lineWidth: 2 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 12, blur: 22, color: "rgba(0,0,0,0.25)" },
        mask: { type: "rounded", params: { radius: 8 } }
    },
    {
        id: "neon-glow", name: "Neon Glow", shape: "rect", cornerRadius: 12,
        defaults: { borderWidth: 14, marginWidth: 28, borderColor: "#00E5FF", marginColor: "#0B0B12" },
        limits: { borderWidth: [6, 60], marginWidth: [0, 140] },
        ornamentLayers: [
            { type: "stroke", placement: "border", params: { strokeStyle: "#00E5FF", lineWidth: 6 } },
            { type: "stroke", placement: "border", params: { strokeStyle: "#FF2EDA", lineWidth: 2 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 0, blur: 30, color: "rgba(0, 229, 255, 0.4)" },
        mask: { type: "rounded", params: { radius: 12 } }
    },
    {
        id: "watercolor-edge", name: "Watercolor", shape: "rect", cornerRadius: 0,
        defaults: { borderWidth: 26, marginWidth: 20, borderColor: "#5AAADB", marginColor: "#FFFFFF" },
        limits: { borderWidth: [10, 120], marginWidth: [0, 140] },
        ornamentLayers: [
            { type: "texture", placement: "border", params: { svg: "<svg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'><circle cx='20' cy='20' r='2' fill='#fff' opacity='0.2'/></svg>", scale: 1 } }
        ],
        shadow: { enabled: false },
        mask: { type: "rect" }
    },
    {
        id: "polaroid-note", name: "Polaroid", shape: "rect", cornerRadius: 2,
        defaults: { borderWidth: 0, marginWidth: 60, borderColor: "#D9D9D9", marginColor: "#FFFFFF" },
        limits: { borderWidth: [0, 20], marginWidth: [30, 200] },
        ornamentLayers: [
            { type: "stroke", placement: "margin", params: { strokeStyle: "#e6e6e6", lineWidth: 1 } }
        ],
        shadow: { enabled: true, offsetX: 0, offsetY: 12, blur: 22, color: "rgba(0,0,0,0.25)" },
        mask: { type: "rounded", params: { radius: 2 } }
    },
    {
        id: "metallic-bevel", name: "Metallic", shape: "rect", cornerRadius: 2,
        defaults: { borderWidth: 24, marginWidth: 18, borderColor: "#A8B1B8", marginColor: "#FFFFFF" },
        limits: { borderWidth: [10, 100], marginWidth: [0, 100] },
        ornamentLayers: [
            { type: "fill", placement: "border", params: { svg: "<svg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0' stop-color='#ECEFF1'/><stop offset='0.5' stop-color='#9AA4AE'/><stop offset='1' stop-color='#E4E7EA'/></linearGradient><rect width='100' height='100' fill='url(#g)'/></svg>", scale: 1 } },
            { type: "stroke", placement: "inner", params: { strokeStyle: "rgba(111, 121, 129, 0.8)", lineWidth: 2 } }
        ],
        shadow: { enabled: false },
        mask: { type: "rect" }
    }
];

// --- Database (IndexedDB) ---
const DB_NAME = "PhotoFramerDB";
const STORE_NAME = "recent_photos";

const db = {
    _db: null,
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onerror = () => reject("DB Error");
            request.onsuccess = (e) => {
                this._db = e.target.result;
                resolve();
            };
            request.onupgradeneeded = (e) => {
                const d = e.target.result;
                if (!d.objectStoreNames.contains(STORE_NAME)) {
                    d.createObjectStore(STORE_NAME, { keyPath: "id" });
                }
            };
        });
    },
    async savePhoto(blob) {
        if (!this._db) await this.init();
        const id = Date.now().toString();
        // Create thumbnail
        const thumb = await this.createThumbnail(blob);
        const tx = this._db.transaction([STORE_NAME], "readwrite");
        tx.objectStore(STORE_NAME).put({ id, blob, thumb, date: new Date() });
        
        // Trim to last 8
        const allKeysReq = tx.objectStore(STORE_NAME).getAllKeys();
        allKeysReq.onsuccess = () => {
            const keys = allKeysReq.result;
            if (keys.length > 8) {
                // simple FIFO not strictly enforced but good enough
                const delTx = this._db.transaction([STORE_NAME], "readwrite");
                delTx.objectStore(STORE_NAME).delete(keys[0]);
            }
        };
    },
    async getRecents() {
        if (!this._db) await this.init();
        return new Promise(resolve => {
            const tx = this._db.transaction([STORE_NAME], "readonly");
            const store = tx.objectStore(STORE_NAME);
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result.reverse()); // Newest first
        });
    },
    createThumbnail(blob) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                const cvs = document.createElement('canvas');
                const scale = 60 / Math.min(img.width, img.height);
                cvs.width = img.width * scale;
                cvs.height = img.height * scale;
                cvs.getContext('2d').drawImage(img, 0, 0, cvs.width, cvs.height);
                resolve(cvs.toDataURL());
            };
            img.src = URL.createObjectURL(blob);
        });
    }
};

// --- Rendering Engine ---
const Renderer = {
    patterns: {}, // Cache patterns

    async getPattern(ctx, svgString, scale) {
        const key = svgString + scale;
        if (this.patterns[key]) return this.patterns[key];

        return new Promise(resolve => {
            const img = new Image();
            const b64 = btoa(svgString);
            img.onload = () => {
                const p = ctx.createPattern(img, 'repeat');
                // Canvas pattern transforms are tricky, simpler to scale SVG or handle in draw
                // For this implementation, we assume SVG fits pattern or user scale adjusts SVG string if needed
                this.patterns[key] = p;
                resolve(p);
            };
            img.src = "data:image/svg+xml;base64," + b64;
        });
    },

    async render(ctx, state, isExport = false) {
        if (!state.image) return;

        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        const t = state.template;
        const p = state.params;

        // Clear
        ctx.clearRect(0, 0, w, h);

        // Calculate Frame Geometry
        // Canvas is size of photo + margins. 
        // We draw margin -> border -> photo
        
        // Fill Background (Margin Color) - Effectively the "Mat"
        ctx.fillStyle = p.marginColor;
        // Draw shadow first if enabled
        ctx.save();
        if (t.shadow.enabled) {
            ctx.shadowColor = t.shadow.color;
            ctx.shadowBlur = t.shadow.blur;
            ctx.shadowOffsetX = t.shadow.offsetX;
            ctx.shadowOffsetY = t.shadow.offsetY;
        }
        
        // Define Outer Shape (Border Edge)
        // For simplicity, we fill the whole canvas with margin color first, 
        // but shadow needs to be cast by the border edge.
        
        // Logic: 
        // 1. Draw "Paper" rect (Margin edge) with shadow
        // 2. Fill "Margin"
        // 3. Draw "Border" rect
        
        const outerX = 0; 
        const outerY = 0;
        const outerW = w;
        const outerH = h;
        
        // If rectangular/rounded
        ctx.beginPath();
        if (t.shape === 'rect' || t.shape === 'rounded') {
             const r = t.cornerRadius || 0;
             ctx.roundRect(outerX + 10, outerY + 10, outerW - 20, outerH - 20, r); // +10 padding for shadow visibility in canvas
        } else if (t.shape === 'oval') {
            ctx.ellipse(w/2, h/2, (w/2)-10, (h/2)-10, 0, 0, 2 * Math.PI);
        }
        
        // Fill Margin Base
        ctx.fill(); 
        ctx.restore(); // Drop shadow done

        // Fill Margin
        ctx.save();
        ctx.fillStyle = p.marginColor;
        // Re-trace for fill (without shadow)
        ctx.beginPath();
        if (t.shape === 'rect' || t.shape === 'rounded') {
             const r = t.cornerRadius || 0;
             ctx.roundRect(outerX + 10, outerY + 10, outerW - 20, outerH - 20, r);
        } else if (t.shape === 'oval') {
             ctx.ellipse(w/2, h/2, (w/2)-10, (h/2)-10, 0, 0, 2 * Math.PI);
        }
        ctx.fill();

        // Draw Margin Ornaments
        await this.drawOrnaments(ctx, t.ornamentLayers, 'margin', w, h);

        // Draw Border
        // The border sits inside the Margin? Or outside?
        // Prompt says: "Border Width", "Margin Width".
        // Typically: [Margin [Border [Photo]]] or [Border [Margin [Photo]]]
        // "Minimal Matte": Border 16, Margin 60. Usually Frame is outer, Mat is inner.
        // Let's assume: Canvas Edge -> Border -> Margin -> Photo.
        
        // Wait, standard framing: Frame (Border) is outermost. Mat (Margin) is between frame and photo.
        // RE-CALCULATION:
        // Outer Rect = Border
        // Inner Rect = Margin
        // Hole = Photo
        
        const bw = parseInt(p.borderWidth);
        const mw = parseInt(p.marginWidth);
        const pad = 20; // Canvas padding for shadow

        // 1. Frame (Border)
        ctx.fillStyle = p.borderColor;
        
        // Draw Border Ornaments (Texture/Pattern on border)
        // If pattern, use it as fillStyle
        
        ctx.beginPath();
        if (t.shape === 'rounded') ctx.roundRect(pad, pad, w-(pad*2), h-(pad*2), t.cornerRadius);
        else if (t.shape === 'oval') ctx.ellipse(w/2, h/2, (w/2)-pad, (h/2)-pad, 0, 0, 2 * Math.PI);
        else ctx.rect(pad, pad, w-(pad*2), h-(pad*2));
        ctx.fill();

        await this.drawOrnaments(ctx, t.ornamentLayers, 'border', w, h);

        // 2. Mat (Margin) - sits inside Border
        // We clear a hole or draw a rect on top? Draw rect on top.
        const matX = pad + bw;
        const matY = pad + bw;
        const matW = w - (pad*2) - (bw*2);
        const matH = h - (pad*2) - (bw*2);

        if (matW > 0 && matH > 0) {
            ctx.fillStyle = p.marginColor;
            ctx.beginPath();
            // Inner radius? Simple approximation
            const innerR = Math.max(0, t.cornerRadius - bw);
            if (t.shape === 'rounded') ctx.roundRect(matX, matY, matW, matH, innerR);
            else if (t.shape === 'oval') ctx.ellipse(w/2, h/2, matW/2, matH/2, 0, 0, 2 * Math.PI);
            else ctx.rect(matX, matY, matW, matH);
            ctx.fill();
            
            await this.drawOrnaments(ctx, t.ornamentLayers, 'margin', w, h, {x: matX, y: matY, w: matW, h: matH});
        }

        // 3. Photo Hole (Clipping)
        const photoX = matX + mw;
        const photoY = matY + mw;
        const photoW = matW - (mw*2);
        const photoH = matH - (mw*2);

        if (photoW > 0 && photoH > 0) {
            ctx.save();
            ctx.beginPath();
            
            // Mask Logic
            if (t.mask.type === 'oval') {
                ctx.ellipse(w/2, h/2, photoW/2, photoH/2, 0, 0, 2 * Math.PI);
            } else if (t.mask.type === 'rounded') {
                ctx.roundRect(photoX, photoY, photoW, photoH, t.mask.params?.radius || 0);
            } else {
                ctx.rect(photoX, photoY, photoW, photoH);
            }
            
            ctx.clip();

            // Draw Photo
            // Transform logic: Center of photo hole
            const centerX = photoX + photoW/2;
            const centerY = photoY + photoH/2;
            
            ctx.translate(centerX, centerY);
            ctx.translate(p.panX, p.panY);
            ctx.scale(p.zoom, p.zoom);
            // Draw image centered
            ctx.drawImage(state.image, -state.image.width/2, -state.image.height/2);
            
            ctx.restore();

            // Inner Stroke (Overlay on top of photo edge)
            await this.drawOrnaments(ctx, t.ornamentLayers, 'inner', w, h, {x: photoX, y: photoY, w: photoW, h: photoH});
        }
        
        ctx.restore();
    },

    async drawOrnaments(ctx, layers, placement, w, h, rect) {
        // Simple implementation for specific overlay types
        const relevant = layers.filter(l => l.placement === placement);
        for (let l of relevant) {
            ctx.save();
            ctx.globalAlpha = l.opacity;
            ctx.globalCompositeOperation = l.blendMode || 'source-over';
            
            if (l.type === 'stroke') {
                ctx.strokeStyle = l.params.strokeStyle;
                ctx.lineWidth = l.params.lineWidth;
                if(rect) ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                else ctx.strokeRect(0,0,w,h); // simplified
            } else if (l.type === 'svgPattern' || l.type === 'texture') {
                // In a real robust app, we'd handle rect vs full canvas
                // Here we just overlay pattern on the last filled path if possible, 
                // but Canvas doesn't remember "last path".
                // We assume this is called immediately after a fill(), so we can use composite 'source-atop' 
                // to clip to the layer below (e.g. the Border fill).
                
                ctx.globalCompositeOperation = 'source-atop';
                const pat = await this.getPattern(ctx, l.params.svg, l.params.scale || 1);
                ctx.fillStyle = pat;
                ctx.fillRect(0,0,w,h);
            }
            ctx.restore();
        }
    }
};

// --- App Logic ---
const app = {
    state: {
        image: null,
        template: TEMPLATES[0],
        params: { ...TEMPLATES[0].defaults, zoom: 1, panX: 0, panY: 0 },
        isDragging: false,
        lastMouse: { x: 0, y: 0 }
    },

    init() {
        this.cacheDOM();
        this.bindEvents();
        this.renderTemplateGrid();
        this.loadRecent();
        
        // Auto-load placeholder logic or wait for upload
        this.updateInspector();
        
        // Initial Canvas Setup
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    },

    cacheDOM() {
        this.dom = {
            input: document.getElementById('file-input'),
            canvas: document.getElementById('studio-canvas'),
            grid: document.getElementById('template-grid'),
            recents: document.getElementById('recent-strip'),
            controls: {
                bw: document.getElementById('inp-border-w'),
                mw: document.getElementById('inp-margin-w'),
                bc: document.getElementById('inp-border-c'),
                mc: document.getElementById('inp-margin-c'),
                zoom: document.getElementById('inp-zoom'),
                valBw: document.getElementById('val-border-w'),
                valMw: document.getElementById('val-margin-w'),
                txtBc: document.getElementById('txt-border-c'),
                txtMc: document.getElementById('txt-margin-c'),
                valZoom: document.getElementById('val-zoom')
            },
            workspace: document.getElementById('workspace')
        };
        this.ctx = this.dom.canvas.getContext('2d');
    },

    bindEvents() {
        // File Input
        this.dom.input.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
        
        // Drag & Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', e => {
            e.preventDefault();
            if(e.dataTransfer.files[0]) this.handleFile(e.dataTransfer.files[0]);
        });

        // Controls
        const c = this.dom.controls;
        c.bw.addEventListener('input', e => this.updateParam('borderWidth', e.target.value));
        c.mw.addEventListener('input', e => this.updateParam('marginWidth', e.target.value));
        c.bc.addEventListener('input', e => this.updateParam('borderColor', e.target.value));
        c.mc.addEventListener('input', e => this.updateParam('marginColor', e.target.value));
        c.zoom.addEventListener('input', e => this.updateParam('zoom', e.target.value));

        // Canvas Interaction (Pan/Zoom)
        const cvs = this.dom.canvas;
        
        // Mouse
        cvs.addEventListener('mousedown', e => {
            this.state.isDragging = true;
            this.state.lastMouse = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('mousemove', e => {
            if (!this.state.isDragging) return;
            const dx = e.clientX - this.state.lastMouse.x;
            const dy = e.clientY - this.state.lastMouse.y;
            this.state.lastMouse = { x: e.clientX, y: e.clientY };
            this.pan(dx, dy);
        });
        window.addEventListener('mouseup', () => this.state.isDragging = false);

        // Wheel Zoom
        this.dom.workspace.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY * -0.001;
            const newZoom = Math.max(0.1, Math.min(4, parseFloat(this.state.params.zoom) + delta));
            this.updateParam('zoom', newZoom);
            this.dom.controls.zoom.value = newZoom;
        });

        // Keyboard
        window.addEventListener('keydown', e => {
             const step = e.shiftKey ? 10 : 2;
             if(e.key === 'ArrowUp') this.pan(0, -step);
             if(e.key === 'ArrowDown') this.pan(0, step);
             if(e.key === 'ArrowLeft') this.pan(-step, 0);
             if(e.key === 'ArrowRight') this.pan(step, 0);
        });
    },

    resizeCanvas() {
        // Resize logic to keep resolution high but fit screen
        // We set internal resolution based on image, display size via CSS
        if(this.state.image) this.render();
    },

    handleFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.state.image = img;
                // Save to IndexedDB
                db.savePhoto(file).then(() => this.loadRecent());
                
                // Reset View
                this.resetView();
                this.render();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },

    async loadRecent() {
        const recents = await db.getRecents();
        this.dom.recents.innerHTML = '<span style="font-size:0.8rem; color:#666; margin-right:10px;">Recent:</span>';
        recents.forEach(r => {
            const img = document.createElement('img');
            img.src = r.thumb;
            img.className = 'recent-thumb';
            img.onclick = () => {
                const i = new Image();
                i.onload = () => {
                    this.state.image = i;
                    this.resetView();
                    this.render();
                };
                i.src = URL.createObjectURL(r.blob);
            };
            this.dom.recents.appendChild(img);
        });
    },

    setTemplate(t) {
        this.state.template = t;
        // Merge defaults, but keep current adjustments if possible? 
        // Better to reset to template defaults for "One Click Apply" feel
        this.state.params = { ...t.defaults, zoom: this.state.params.zoom, panX: this.state.params.panX, panY: this.state.params.panY };
        
        // Highlight UI
        document.querySelectorAll('.template-card').forEach(c => c.classList.remove('active'));
        document.getElementById(`tpl-${t.id}`).classList.add('active');
        
        this.updateInspector();
        this.render();
    },

    updateInspector() {
        const p = this.state.params;
        const c = this.dom.controls;
        const lim = this.state.template.limits;

        c.bw.value = p.borderWidth; c.bw.min = lim.borderWidth[0]; c.bw.max = lim.borderWidth[1];
        c.valBw.textContent = p.borderWidth;

        c.mw.value = p.marginWidth; c.mw.min = lim.marginWidth[0]; c.mw.max = lim.marginWidth[1];
        c.valMw.textContent = p.marginWidth;

        c.bc.value = p.borderColor.slice(0, 7); // Handle RGBA later if needed, input color is hex
        c.txtBc.textContent = p.borderColor;
        
        c.mc.value = p.marginColor.slice(0, 7);
        c.txtMc.textContent = p.marginColor;

        c.zoom.value = p.zoom;
        c.valZoom.textContent = Math.round(p.zoom * 100) + '%';
    },

    updateParam(key, val) {
        this.state.params[key] = val;
        
        // Update Text Labels
        if (key === 'borderWidth') this.dom.controls.valBw.textContent = val;
        if (key === 'marginWidth') this.dom.controls.valMw.textContent = val;
        if (key === 'borderColor') this.dom.controls.txtBc.textContent = val;
        if (key === 'marginColor') this.dom.controls.txtMc.textContent = val;
        if (key === 'zoom') this.dom.controls.valZoom.textContent = Math.round(val * 100) + '%';

        this.render();
    },

    pan(dx, dy) {
        this.state.params.panX += dx;
        this.state.params.panY += dy;
        this.render();
    },

    resetView() {
        this.state.params.panX = 0;
        this.state.params.panY = 0;
        this.state.params.zoom = 1;
        this.updateInspector();
        this.render();
    },
    
    fitView() {
        // Logic to fit photo within mask
        // Simplified:
        this.state.params.zoom = 0.5;
        this.state.params.panX = 0;
        this.state.params.panY = 0;
        this.updateInspector();
        this.render();
    },

    render() {
        if (!this.state.image) return;
        
        // Define canvas Resolution based on Image Size + Padding
        // We want High Res export, but responsive preview
        // Strategy: Canvas internal resolution = Image Size + Max Frames
        // CSS scales it down.
        
        const img = this.state.image;
        const pad = 200; // Extra space for frames
        const w = img.width + pad;
        const h = img.height + pad;
        
        // Only resize if significantly different to avoid thrashing
        if (this.dom.canvas.width !== w || this.dom.canvas.height !== h) {
             this.dom.canvas.width = w;
             this.dom.canvas.height = h;
        }

        Renderer.render(this.ctx, this.state);
    },

    renderTemplateGrid() {
        this.dom.grid.innerHTML = TEMPLATES.map((t, index) => `
            <div class="template-card ${index === 0 ? 'active' : ''}" id="tpl-${t.id}" onclick="app.setTemplate(TEMPLATES[${index}])">
                <div class="template-preview" style="background:${t.defaults.marginColor}; display:flex; align-items:center; justify-content:center;">
                    <div style="width:60%; height:60%; border:${t.defaults.borderWidth/4}px solid ${t.defaults.borderColor}; background:#ccc;"></div>
                </div>
                <div class="template-name">${t.name}</div>
            </div>
        `).join('');
    },

    exportImage(type) {
        if (!this.state.image) return;
        
        // Provide feedback
        this.showToast("Generating image...");

        setTimeout(() => {
            // For export, we might want a clean canvas without the "20px padding" we added for shadows in preview?
            // Actually, shadows need padding.
            const url = this.dom.canvas.toDataURL(type === 'jpeg' ? 'image/jpeg' : 'image/png', 0.9);
            
            if (type === 'clipboard') {
                this.dom.canvas.toBlob(blob => {
                    try {
                        const item = new ClipboardItem({ "image/png": blob });
                        navigator.clipboard.write([item]);
                        this.showToast("Copied to Clipboard!");
                    } catch (err) {
                        this.showToast("Clipboard failed, downloading instead.");
                        this.downloadFile(url, 'framed-photo.png');
                    }
                });
            } else {
                const ext = type === 'jpeg' ? 'jpg' : 'png';
                this.downloadFile(url, `framed-photo.${ext}`);
                this.showToast("Download started!");
            }
        }, 50);
    },

    downloadFile(url, name) {
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.click();
    },

    showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 3000);
    }
};

// Start
document.addEventListener('DOMContentLoaded', () => app.init());

    </script>
</body>
</html>
