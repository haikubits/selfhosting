<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Collage Studio</title>
    <style>
        :root {
            --bg-body: #121212;
            --bg-panel: #1e1e1e;
            --bg-canvas: #000000;
            --border: #333;
            --accent: #3b82f6;
            --text: #fff;
            --text-muted: #888;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            margin: 0;
            background: var(--bg-body);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- HEADER --- */
        header {
            height: 50px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            background: var(--bg-panel);
            z-index: 20;
            flex-shrink: 0;
        }
        
        .logo { font-weight: 600; display:flex; gap:10px; align-items:center; }
        
        .header-actions { display: flex; gap: 8px; }
        
        button { cursor: pointer; font-family: inherit; }
        
        .btn-icon {
            background: none; border: 1px solid var(--border); color: var(--text);
            width: 36px; height: 36px; border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
        }
        .btn-icon:hover { background: #333; }
        
        .btn-primary {
            background: var(--accent); color: white; border: none;
            padding: 0 16px; height: 36px; border-radius: 20px;
            font-weight: 600; font-size: 14px;
        }
        .btn-primary:active { opacity: 0.8; }

        /* --- MAIN LAYOUT --- */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* WORKSPACE (Canvas) */
        .workspace {
            flex: 1;
            background: var(--bg-canvas);
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #collage-area {
            background: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transition: width 0.3s, height 0.3s;
            position: relative;
        }

        .frame {
            position: absolute;
            overflow: hidden;
            background: #ddd;
        }
        .frame.selected { z-index: 10; }
        .frame.selected::after {
            content:''; position: absolute; inset:0;
            border: 2px solid var(--accent); pointer-events: none;
        }
        .frame img {
            position: absolute; top:50%; left:50%;
            pointer-events: none;
            /* Ensure cover logic in preview */
            min-width: 100%; min-height: 100%;
            object-fit: cover; 
            transform-origin: center;
        }

        /* SIDEBAR / BOTTOM SHEET */
        .controls-panel {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            z-index: 15;
            border-left: 1px solid var(--border);
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--bg-panel);
            flex-shrink: 0;
        }
        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid transparent;
            background: none; border-top: none; border-left: none; border-right: none;
        }
        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            background: rgba(255,255,255,0.03);
        }

        /* Tab Content Areas */
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: none;
        }
        .tab-content.active { display: block; }

        /* UI Elements */
        .section-title {
            font-size: 11px; text-transform: uppercase; color: var(--text-muted);
            margin: 0 0 10px 0; font-weight: 700; letter-spacing: 1px;
        }
        
        .control-row {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 12px; gap: 10px;
        }
        
        label { font-size: 13px; color: var(--text); }
        
        input[type="range"] {
            flex: 1; height: 4px; background: #444;
            appearance: none; border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 18px; height: 18px;
            background: var(--text); border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        select, input[type="color"] {
            background: #333; color: white; border: 1px solid #444;
            height: 30px; border-radius: 4px; padding: 0 5px;
        }

        /* Grids */
        .grid { display: grid; gap: 8px; }
        .grid-2 { grid-template-columns: 1fr 1fr; }
        .grid-3 { grid-template-columns: repeat(3, 1fr); }

        .thumb-btn {
            aspect-ratio: 1; background: #333; border: 1px solid #444;
            border-radius: 4px; cursor: pointer; overflow: hidden; position: relative;
        }
        .thumb-btn img { width: 100%; height: 100%; object-fit: cover; }
        .thumb-btn svg { width: 100%; height: 100%; fill: #666; padding: 5px; }
        .thumb-btn:hover { border-color: var(--accent); }

        .add-photo-btn {
            background: #222; border: 2px dashed #444; color: #888;
            border-radius: 8px; padding: 20px; text-align: center;
            margin-bottom: 20px; cursor: pointer;
        }

        /* Handles */
        .resize-handle {
            position: absolute; width: 20px; height: 20px;
            background: var(--accent); border: 2px solid white; border-radius: 50%;
            z-index: 20; transform: translate(-50%, -50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .h-n { top: 0; left: 50%; }
        .h-s { top: 100%; left: 50%; }
        .h-w { top: 50%; left: 0; }
        .h-e { top: 50%; left: 100%; }

        /* RESPONSIVE LOGIC */
        /* Desktop */
        @media (min-width: 769px) {
            .app-container { flex-direction: row; }
            .controls-panel { width: 320px; height: 100%; }
            .tabs { order: -1; } /* Tabs at top */
        }

        /* Mobile */
        @media (max-width: 768px) {
            .app-container { flex-direction: column; }
            .workspace { height: 55%; border-bottom: 1px solid var(--border); }
            .controls-panel { height: 45%; border-left: none; width: 100%; }
            .tabs { order: -1; } /* Tabs at top of panel */
            
            /* Increase touch targets */
            .tab { padding: 15px 5px; font-size: 11px; } 
            input[type="range"]::-webkit-slider-thumb { width: 24px; height: 24px; }
        }

        /* Landscape Mobile */
        @media (max-width: 850px) and (orientation: landscape) {
             .app-container { flex-direction: row; }
             .workspace { height: 100%; width: auto; }
             .controls-panel { width: 300px; height: 100%; }
        }
        
        #toast {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); padding: 15px 25px; border-radius: 30px;
            color: white; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100;
        }
    </style>
</head>
<body>

<header>
    <div class="logo">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>
        <span>Collage Studio</span>
    </div>
    <div class="header-actions">
        <button class="btn-icon" onclick="app.undo()" title="Undo">↶</button>
        <button class="btn-icon" onclick="app.redo()" title="Redo">↷</button>
        <button class="btn-primary" onclick="app.exportCollage()">Save</button>
    </div>
</header>

<div class="app-container">
    <div class="workspace" id="workspace">
        <div id="collage-area"></div>
    </div>

    <div class="controls-panel">
        <div class="tabs">
            <button id="btn-tab-photos" class="tab active" onclick="app.setTab('photos')">Photos</button>
            <button id="btn-tab-layout" class="tab" onclick="app.setTab('layout')">Layout</button>
            <button id="btn-tab-edit" class="tab" onclick="app.setTab('edit')">Edit</button>
            <button id="btn-tab-canvas" class="tab" onclick="app.setTab('canvas')">Canvas</button>
        </div>

        <!-- PHOTOS TAB -->
        <div id="tab-photos" class="tab-content active">
            <div class="add-photo-btn" onclick="document.getElementById('file-input').click()">
                <span>+ Tap to Add Photos</span>
            </div>
            <input type="file" id="file-input" multiple accept="image/*" style="display:none">
            <h4 class="section-title">Your Library</h4>
            <div class="grid grid-3" id="photo-tray"></div>
        </div>

        <!-- LAYOUT TAB -->
        <div id="tab-layout" class="tab-content">
            <h4 class="section-title">Templates</h4>
            <div class="grid grid-3" id="template-list"></div>
        </div>

        <!-- EDIT TAB -->
        <div id="tab-edit" class="tab-content">
            <div id="msg-no-sel" style="text-align:center; margin-top:40px; color:#666;">
                Tap a photo frame to edit
            </div>
            <div id="controls-sel" style="display:none;">
                <h4 class="section-title">Image Transform</h4>
                <div class="control-row">
                    <label>Zoom</label>
                    <input type="range" id="inp-zoom" min="0.1" max="3" step="0.1" oninput="app.updateImage('zoom', this.value)">
                </div>
                <div class="control-row">
                    <label>Rotate</label>
                    <input type="range" id="inp-rot" min="-180" max="180" step="90" oninput="app.updateImage('rotate', this.value)">
                </div>
                <div class="grid grid-2" style="margin-bottom:20px;">
                    <button class="btn-icon" style="width:100%; border-radius:4px; font-size:12px;" onclick="app.fitImage()">Fit</button>
                    <button class="btn-icon" style="width:100%; border-radius:4px; font-size:12px; color:#f87171; border-color:#7f1d1d;" onclick="app.clearImage()">Clear</button>
                </div>

                <h4 class="section-title">Frame Style</h4>
                <div class="control-row">
                    <label>Roundness</label>
                    <input type="range" id="inp-br" min="0" max="50" oninput="app.updateFrame('br', this.value)">
                </div>
                <div class="control-row">
                    <label>Border</label>
                    <input type="range" id="inp-bw" min="0" max="20" oninput="app.updateFrame('bw', this.value)">
                </div>
                <div class="control-row">
                    <label>Color</label>
                    <input type="color" id="inp-bc" onchange="app.updateFrame('bc', this.value)">
                </div>
            </div>
        </div>

        <!-- CANVAS TAB -->
        <div id="tab-canvas" class="tab-content">
            <h4 class="section-title">Dimensions</h4>
            <div class="control-row">
                <label>Aspect Ratio</label>
                <select id="inp-ratio" onchange="app.updateCanvas('ratio', this.value)" style="width:120px;">
                    <option value="1:1">1:1 Square</option>
                    <option value="4:5">4:5 Portrait</option>
                    <option value="9:16">9:16 Story</option>
                    <option value="3:4">3:4 Photo</option>
                    <option value="16:9">16:9 Cinema</option>
                    <option value="1.414">A4 Paper</option>
                </select>
            </div>
            
            <h4 class="section-title">Spacing</h4>
            <div class="control-row">
                <label>Gap</label>
                <input type="range" id="inp-gap" min="0" max="50" oninput="app.updateCanvas('gap', this.value)">
            </div>
            <div class="control-row">
                <label>Padding</label>
                <input type="range" id="inp-pad" min="0" max="100" oninput="app.updateCanvas('pad', this.value)">
            </div>
            <div class="control-row">
                <label>Background</label>
                <input type="color" id="inp-bg" onchange="app.updateCanvas('bg', this.value)">
            </div>
            
            <div style="margin-top:30px; border-top:1px solid #333; padding-top:20px;">
                <button class="btn-primary" style="background:#222; border:1px solid #d32f2f; color:#ef5350; width:100%;" onclick="app.reset()">Reset Project</button>
            </div>
        </div>
    </div>
</div>

<div id="toast">Saved!</div>

<script>
const TEMPLATES = {
    'grid-1': [{x:0,y:0,w:100,h:100}],
    'grid-2v': [{x:0,y:0,w:50,h:100}, {x:50,y:0,w:50,h:100}],
    'grid-2h': [{x:0,y:0,w:100,h:50}, {x:0,y:50,w:100,h:50}],
    'grid-3': [{x:0,y:0,w:50,h:100}, {x:50,y:0,w:50,h:50}, {x:50,y:50,w:50,h:50}],
    'grid-4': [{x:0,y:0,w:50,h:50}, {x:50,y:0,w:50,h:50}, {x:0,y:50,w:50,h:50}, {x:50,y:50,w:50,h:50}],
    'grid-6': [{x:0,y:0,w:33.3,h:50},{x:33.3,y:0,w:33.3,h:50},{x:66.6,y:0,w:33.3,h:50},{x:0,y:50,w:33.3,h:50},{x:33.3,y:50,w:33.3,h:50},{x:66.6,y:50,w:33.3,h:50}],
};

class App {
    constructor() {
        this.data = {
            canvas: { ratio: '1:1', gap: 5, padding: 20, bg: '#ffffff' },
            frames: [],
            images: {},
            sel: null
        };
        this.history = [];
        this.histIdx = -1;
        this.drag = null;

        this.els = {
            ws: document.getElementById('workspace'),
            area: document.getElementById('collage-area'),
            fileInput: document.getElementById('file-input'),
            tray: document.getElementById('photo-tray')
        };
        
        this.init();
    }

    init() {
        // Load Data
        const saved = localStorage.getItem('cs_data');
        if(saved) {
            try { this.data = JSON.parse(saved); } catch(e){}
        } else {
            this.loadTemplate('grid-4', false);
        }

        this.renderTemplates();
        this.setupEvents();
        this.render();
        
        // Mobile check to set initial tab
        if(window.innerWidth < 768) this.setTab('photos');
        else this.setTab('photos');
    }

    setupEvents() {
        this.els.fileInput.onchange = (e) => this.addPhotos(e.target.files);
        
        // Global pointer events for dragging
        document.addEventListener('pointermove', this.onMove.bind(this));
        document.addEventListener('pointerup', this.onUp.bind(this));
        
        // Prevent default touch actions on workspace
        this.els.area.addEventListener('pointerdown', (e) => {
            // If clicking background (not frame), deselect
            if(e.target === this.els.area) this.select(null);
        });
    }

    /* --- TABS --- */
    setTab(id) {
        document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        
        document.getElementById(`btn-tab-${id}`).classList.add('active');
        document.getElementById(`tab-${id}`).classList.add('active');
    }

    /* --- HISTORY --- */
    pushHist() {
        if(this.histIdx < this.history.length - 1) {
            this.history = this.history.slice(0, this.histIdx + 1);
        }
        this.history.push(JSON.stringify(this.data));
        if(this.history.length > 20) this.history.shift();
        else this.histIdx++;
        
        this.saveLS();
    }

    undo() {
        if(this.histIdx > 0) {
            this.histIdx--;
            this.data = JSON.parse(this.history[this.histIdx]);
            this.render();
            this.syncUI();
        }
    }

    redo() {
        if(this.histIdx < this.history.length - 1) {
            this.histIdx++;
            this.data = JSON.parse(this.history[this.histIdx]);
            this.render();
            this.syncUI();
        }
    }

    saveLS() {
        localStorage.setItem('cs_data', JSON.stringify(this.data));
    }
    
    reset() {
        if(confirm("Reset Project?")) {
            this.data.images = {};
            this.loadTemplate('grid-4');
        }
    }

    /* --- LOGIC --- */
    async addPhotos(files) {
        for(let file of files) {
            if(!file.type.startsWith('image')) continue;
            const bmp = await createImageBitmap(file);
            
            // Downscale
            let w = bmp.width, h = bmp.height;
            const max = 1500;
            if(w > max || h > max) {
                const s = max / Math.max(w,h);
                w *= s; h *= s;
            }
            
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            cvs.getContext('2d').drawImage(bmp,0,0,w,h);
            const url = cvs.toDataURL('image/jpeg', 0.85);
            
            const id = 'img_'+Math.random().toString(36).substr(2);
            this.data.images[id] = url;
            
            // Auto-fill
            const empty = this.data.frames.find(f => !f.imgId);
            if(empty) {
                empty.imgId = id;
                empty.pan = {x:0, y:0};
                empty.zoom = 1;
                empty.rot = 0;
            }
        }
        this.pushHist();
        this.render();
    }

    loadTemplate(key, save=true) {
        if(save) this.pushHist();
        const tpl = TEMPLATES[key];
        const oldFrames = this.data.frames || [];
        
        this.data.frames = tpl.map((box, i) => {
            const old = oldFrames[i] || {};
            return {
                id: i,
                x: box.x, y: box.y, w: box.w, h: box.h,
                // Inherit image or null
                imgId: old.imgId || null,
                pan: old.pan || {x:0, y:0},
                zoom: old.zoom || 1,
                rot: old.rot || 0,
                // Styles
                br: 0, bw: 0, bc: '#ffffff'
            };
        });
        this.render();
    }

    select(id) {
        this.data.sel = id;
        this.render(); // Redraw handles
        this.syncUI();
        if(id !== null && window.innerWidth < 768) this.setTab('edit');
    }

    /* --- UPDATES --- */
    updateCanvas(key, val) {
        if(key === 'ratio') this.data.canvas.ratio = val;
        if(key === 'gap') this.data.canvas.gap = parseInt(val);
        if(key === 'pad') this.data.canvas.padding = parseInt(val);
        if(key === 'bg') this.data.canvas.bg = val;
        this.render();
        // Debounce history? For now push on change
        // ideally pushHist on mouseup. 
    }

    updateFrame(key, val) {
        if(this.data.sel === null) return;
        const f = this.data.frames[this.data.sel];
        if(key === 'br') f.br = parseInt(val);
        if(key === 'bw') f.bw = parseInt(val);
        if(key === 'bc') f.bc = val;
        this.render();
    }

    updateImage(key, val) {
        if(this.data.sel === null) return;
        const f = this.data.frames[this.data.sel];
        if(key === 'zoom') f.zoom = parseFloat(val);
        if(key === 'rotate') f.rot = parseInt(val);
        this.render();
    }
    
    fitImage() {
        if(this.data.sel === null) return;
        const f = this.data.frames[this.data.sel];
        f.zoom = 1; f.pan = {x:0,y:0}; f.rot = 0;
        this.render(); this.syncUI();
        this.pushHist();
    }
    
    clearImage() {
        if(this.data.sel === null) return;
        this.data.frames[this.data.sel].imgId = null;
        this.render(); this.syncUI();
        this.pushHist();
    }

    /* --- RENDERING --- */
    render() {
        this.renderWorkspace();
        this.renderTray();
    }
    
    renderTemplates() {
        const list = document.getElementById('template-list');
        list.innerHTML = '';
        Object.keys(TEMPLATES).forEach(k => {
            const btn = document.createElement('div');
            btn.className = 'thumb-btn';
            btn.onclick = () => this.loadTemplate(k);
            let svg = `<svg viewBox="0 0 100 100">`;
            TEMPLATES[k].forEach(r => svg+=`<rect x="${r.x}" y="${r.y}" width="${r.w}" height="${r.h}" fill="#555" stroke="#222" stroke-width="2"/>`);
            svg+=`</svg>`;
            btn.innerHTML = svg;
            list.appendChild(btn);
        });
    }

    renderWorkspace() {
        const c = this.data.canvas;
        const rect = this.els.ws.getBoundingClientRect();
        
        // Calc Dimensions
        let r = 1;
        if(c.ratio.includes(':')) {
            const [w,h] = c.ratio.split(':');
            r = w/h;
        } else r = parseFloat(c.ratio);
        
        const padUI = 30;
        const maxW = rect.width - padUI;
        const maxH = rect.height - padUI;
        
        let w = maxW;
        let h = w / r;
        if(h > maxH) { h = maxH; w = h * r; }
        
        this.els.area.style.width = w + 'px';
        this.els.area.style.height = h + 'px';
        this.els.area.style.background = c.bg;
        this.els.area.innerHTML = ''; // Clear

        // Render Frames
        const gap = c.gap;
        const pad = c.padding;
        const innerW = w - (pad*2);
        const innerH = h - (pad*2);

        this.data.frames.forEach(f => {
            const el = document.createElement('div');
            el.className = 'frame';
            if(this.data.sel === f.id) el.classList.add('selected');
            
            // Calc Geometry
            const x = pad + (f.x/100 * innerW);
            const y = pad + (f.y/100 * innerH);
            const fw = (f.w/100 * innerW);
            const fh = (f.h/100 * innerH);
            
            // Gap logic
            const gapAdj = gap/2;
            el.style.left = (x + gapAdj) + 'px';
            el.style.top = (y + gapAdj) + 'px';
            el.style.width = Math.max(0, fw - gap) + 'px';
            el.style.height = Math.max(0, fh - gap) + 'px';
            
            el.style.borderRadius = f.br + 'px';
            el.style.border = f.bw > 0 ? `${f.bw}px solid ${f.bc}` : 'none';

            // Image
            if(f.imgId && this.data.images[f.imgId]) {
                const img = document.createElement('img');
                img.src = this.data.images[f.imgId];
                // Transform
                img.style.transform = `translate(-50%, -50%) translate(${f.pan.x}px, ${f.pan.y}px) rotate(${f.rot}deg) scale(${f.zoom})`;
                el.appendChild(img);
            }

            // Handles
            if(this.data.sel === f.id) {
                const handles = ['n','e','s','w'];
                handles.forEach(dir => {
                    const h = document.createElement('div');
                    h.className = 'resize-handle h-'+dir;
                    h.onpointerdown = (e) => {
                        e.stopPropagation();
                        this.startDrag(e, 'resize', f, dir);
                    };
                    el.appendChild(h);
                });
            }

            // Events
            el.onpointerdown = (e) => {
                if(e.target.classList.contains('resize-handle')) return;
                e.stopPropagation();
                this.select(f.id);
                if(f.imgId) this.startDrag(e, 'pan', f);
            };

            this.els.area.appendChild(el);
        });
    }
    
    renderTray() {
        this.els.tray.innerHTML = '';
        Object.entries(this.data.images).forEach(([id, url]) => {
            const btn = document.createElement('div');
            btn.className = 'thumb-btn';
            const img = document.createElement('img');
            img.src = url;
            btn.appendChild(img);
            btn.onclick = () => {
                if(this.data.sel !== null) {
                    this.pushHist();
                    const f = this.data.frames[this.data.sel];
                    f.imgId = id; f.pan={x:0,y:0}; f.zoom=1; f.rot=0;
                    this.render(); this.syncUI();
                }
            };
            this.els.tray.appendChild(btn);
        });
    }

    syncUI() {
        const c = this.data.canvas;
        document.getElementById('inp-ratio').value = c.ratio;
        document.getElementById('inp-gap').value = c.gap;
        document.getElementById('inp-pad').value = c.padding;
        document.getElementById('inp-bg').value = c.bg;
        
        const f = this.data.sel !== null ? this.data.frames[this.data.sel] : null;
        const paneSel = document.getElementById('controls-sel');
        const paneNoSel = document.getElementById('msg-no-sel');
        
        if(f) {
            paneSel.style.display = 'block';
            paneNoSel.style.display = 'none';
            document.getElementById('inp-zoom').value = f.zoom;
            document.getElementById('inp-rot').value = f.rot;
            document.getElementById('inp-br').value = f.br;
            document.getElementById('inp-bw').value = f.bw;
            document.getElementById('inp-bc').value = f.bc;
        } else {
            paneSel.style.display = 'none';
            paneNoSel.style.display = 'block';
        }
    }

    /* --- INTERACTION --- */
    startDrag(e, type, frame, dir=null) {
        this.drag = {
            type, frame, dir,
            sx: e.clientX, sy: e.clientY,
            origPan: {...frame.pan},
            origGeo: {x:frame.x, y:frame.y, w:frame.w, h:frame.h}
        };
    }
    
    onMove(e) {
        if(!this.drag) return;
        e.preventDefault();
        const d = this.drag;
        
        if(d.type === 'pan') {
            const dx = e.clientX - d.sx;
            const dy = e.clientY - d.sy;
            d.frame.pan.x = d.origPan.x + dx;
            d.frame.pan.y = d.origPan.y + dy;
            
            // Direct DOM update for speed
            const el = document.querySelector('.frame.selected img');
            if(el) el.style.transform = `translate(-50%, -50%) translate(${d.frame.pan.x}px, ${d.frame.pan.y}px) rotate(${d.frame.rot}deg) scale(${d.frame.zoom})`;
        }
        else if(d.type === 'resize') {
            // Convert px to %
            const rect = this.els.area.getBoundingClientRect();
            const pad = this.data.canvas.padding;
            const innerW = rect.width - (pad*2);
            const innerH = rect.height - (pad*2);
            
            const dxPct = (e.clientX - d.sx) / innerW * 100;
            const dyPct = (e.clientY - d.sy) / innerH * 100;
            
            const f = d.frame;
            const o = d.origGeo;
            
            if(d.dir === 'e') f.w = Math.max(5, o.w + dxPct);
            if(d.dir === 's') f.h = Math.max(5, o.h + dyPct);
            if(d.dir === 'w') {
                const diff = Math.min(o.w - 5, dxPct);
                f.x = o.x + diff; f.w = o.w - diff;
            }
            if(d.dir === 'n') {
                const diff = Math.min(o.h - 5, dyPct);
                f.y = o.y + diff; f.h = o.h - diff;
            }
            this.renderWorkspace();
        }
    }
    
    onUp() {
        if(this.drag) {
            this.pushHist();
            this.drag = null;
        }
    }

    /* --- EXPORT --- */
    async exportCollage() {
        const toast = document.getElementById('toast');
        toast.style.opacity = 1; toast.innerText = "Rendering...";
        
        // Wait for UI render
        await new Promise(r=>setTimeout(r,50));
        
        const scale = 2;
        const c = this.data.canvas;
        
        // Determine Size
        let ratio = 1;
        if(c.ratio.includes(':')) { const [w,h] = c.ratio.split(':'); ratio=w/h; }
        else ratio = parseFloat(c.ratio);
        
        const w = 1200 * scale;
        const h = (1200 / ratio) * scale;
        
        const cvs = document.createElement('canvas');
        cvs.width = w; cvs.height = h;
        const ctx = cvs.getContext('2d');
        
        ctx.fillStyle = c.bg;
        ctx.fillRect(0,0,w,h);
        
        // Scale Factor (Canvas Pixel Width / 800 (approx screen width used for sliders) ?)
        // Actually, logic is: Padding is in "units" that map to screen pixels in DOM.
        // We need to establish a consistent Unit-to-ExportPixel ratio.
        // In renderWorkspace, we map padding pixels to DOM size.
        // Here, we define the Export is 1200px wide base. 
        // We assume the user sees '20' padding on a ~800px workspace. 
        // So ratio is w / 800 roughly. Or just treat slider values as relative to 1000px.
        const unit = w / 1000;
        
        const pad = c.padding * unit;
        const gap = c.gap * unit;
        const innerW = w - (pad*2);
        const innerH = h - (pad*2);
        
        for(let f of this.data.frames) {
            const x = pad + (f.x/100 * innerW);
            const y = pad + (f.y/100 * innerH);
            const fw = (f.w/100 * innerW);
            const fh = (f.h/100 * innerH);
            
            const gx = x + gap/2;
            const gy = y + gap/2;
            const gw = Math.max(0, fw - gap);
            const gh = Math.max(0, fh - gap);
            
            // Clip
            ctx.save();
            ctx.beginPath();
            const br = f.br * unit;
            if(ctx.roundRect) ctx.roundRect(gx,gy,gw,gh,br);
            else ctx.rect(gx,gy,gw,gh);
            ctx.clip();
            
            ctx.fillStyle = '#eee';
            ctx.fillRect(gx,gy,gw,gh);
            
            if(f.imgId && this.data.images[f.imgId]) {
                const img = new Image();
                img.src = this.data.images[f.imgId];
                await new Promise(r => { if(img.complete)r(); else img.onload=r; });
                
                const iw = img.naturalWidth;
                const ih = img.naturalHeight;
                
                ctx.save();
                ctx.translate(gx + gw/2, gy + gh/2);
                ctx.translate(f.pan.x * unit, f.pan.y * unit);
                ctx.rotate(f.rot * Math.PI/180);
                
                // Cover Logic
                // If rotated 90, target dimensions swap
                let tw = gw, th = gh;
                if(Math.abs(f.rot) % 180 === 90) { tw = gh; th = gw; }
                
                const s1 = tw/iw;
                const s2 = th/ih;
                const s = Math.max(s1,s2) * f.zoom;
                
                ctx.scale(s,s);
                ctx.drawImage(img, -iw/2, -ih/2);
                ctx.restore();
            }
            ctx.restore();
            
            if(f.bw > 0) {
                ctx.lineWidth = f.bw * unit;
                ctx.strokeStyle = f.bc;
                ctx.beginPath();
                if(ctx.roundRect) ctx.roundRect(gx,gy,gw,gh,br);
                else ctx.rect(gx,gy,gw,gh);
                ctx.stroke();
            }
        }
        
        const link = document.createElement('a');
        link.download = 'collage.png';
        link.href = cvs.toDataURL();
        link.click();
        
        toast.innerText = "Downloaded!";
        setTimeout(()=>toast.style.opacity=0, 2000);
    }
}

// Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
    };
}

const app = new App();
</script>
</body>
</html>


