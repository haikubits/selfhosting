<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collage Studio | Zero-Backend</title>
    <meta name="description" content="A private, in-browser photo collage maker.">
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --bg-panel: #262626;
            --bg-input: #333333;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --text-main: #f3f4f6;
            --text-muted: #9ca3af;
            --border: #404040;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --handle-size: 10px;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-drag: none; }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Layout --- */
        header {
            height: 50px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            z-index: 10;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 5;
            transition: width 0.2s;
        }
        
        .sidebar.right {
            border-left: 1px solid var(--border);
            border-right: none;
        }

        .workspace {
            flex: 1;
            background-color: #121212;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* --- Components --- */
        button {
            background-color: var(--bg-input);
            color: var(--text-main);
            border: 1px solid var(--border);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.1s;
        }
        button:hover { background-color: var(--border); }
        button.primary { background-color: var(--accent); border-color: var(--accent); }
        button.primary:hover { background-color: var(--accent-hover); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-group { display: flex; gap: 0.5rem; }
        
        h1 { font-size: 1.1rem; font-weight: 600; margin: 0; }
        h3 { font-size: 0.8rem; text-transform: uppercase; color: var(--text-muted); margin: 1.5rem 0 0.5rem 0; padding: 0 1rem; letter-spacing: 0.05em; }

        .control-group { padding: 0.5rem 1rem; display: flex; flex-direction: column; gap: 0.5rem; }
        label { font-size: 0.8rem; color: var(--text-muted); display: flex; justify-content: space-between; }
        
        input[type="range"] { width: 100%; accent-color: var(--accent); }
        input[type="color"] { width: 100%; height: 30px; border: none; background: none; padding: 0; cursor: pointer; }
        input[type="text"], input[type="number"], select {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            width: 100%;
        }

        /* --- Thumbnails --- */
        .photo-tray {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 10px;
        }
        .thumb {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 4px;
            cursor: grab;
            border: 2px solid transparent;
            background: #000;
        }
        .thumb:hover { border-color: var(--text-muted); }
        .thumb:active { cursor: grabbing; }

        .drop-zone {
            border: 2px dashed var(--border);
            margin: 10px;
            padding: 20px;
            text-align: center;
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
        }
        .drop-zone:hover { border-color: var(--accent); color: var(--accent); }

        /* --- Templates --- */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 10px;
        }
        .template-item {
            aspect-ratio: 1;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }
        .template-item:hover { border-color: var(--accent); }
        .template-item svg { width: 100%; height: 100%; fill: var(--text-muted); padding: 4px; }

        /* --- Canvas & Frames --- */
        #collage-area {
            background-color: #fff;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            position: relative;
            transform-origin: center;
            /* width/height set by JS */
            transition: width 0.3s, height 0.3s;
        }

        .frame {
            position: absolute;
            overflow: hidden;
            box-sizing: border-box;
            background-color: #eee;
            /* Borders/Shadows set inline */
            touch-action: none;
            cursor: pointer;
        }
        
        .frame.selected {
            z-index: 100;
        }
        
        /* Selection Outline (Pseudo-element to sit outside border) */
        .frame.selected::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border: 2px solid var(--accent);
            pointer-events: none;
            z-index: 101;
        }

        .frame img {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center;
            /* Transform set by JS */
            pointer-events: none; /* Let frame handle events */
            will-change: transform;
        }

        .empty-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 2rem;
            pointer-events: none;
        }

        /* --- Toast --- */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        /* Responsive tweaks */
        @media (max-width: 768px) {
            .main-container { flex-direction: column; }
            .sidebar { width: 100%; height: auto; max-height: 200px; order: 2; flex-direction: row; overflow-x: auto; }
            .sidebar.right { order: 3; }
            .workspace { order: 1; height: 50vh; }
            .photo-tray, .template-grid { display: flex; overflow-x: auto; }
            .thumb, .template-item { width: 60px; flex-shrink: 0; }
        }
    </style>
</head>
<body>

    <header>
        <div style="display:flex; align-items:center; gap:10px;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
            <h1>Collage Studio</h1>
        </div>
        <div class="btn-group">
            <button onclick="app.undo()" title="Undo (Ctrl+Z)">↶</button>
            <button onclick="app.redo()" title="Redo (Ctrl+Y)">↷</button>
            <button class="primary" onclick="app.exportCollage()">Download</button>
            <button onclick="app.copyToClipboard()">Copy</button>
        </div>
    </header>

    <div class="main-container">
        <!-- LEFT SIDEBAR: Imports & Templates -->
        <div class="sidebar">
            <div class="drop-zone" id="drop-zone">
                Click to Add Photos<br>or Drag & Drop
            </div>
            <input type="file" id="file-input" multiple accept="image/*" style="display:none">
            
            <h3>Photos</h3>
            <div class="photo-tray" id="photo-tray">
                <!-- Thumbnails go here -->
            </div>

            <h3>Templates</h3>
            <div class="template-grid" id="template-list">
                <!-- SVG Templates injected here -->
            </div>
        </div>

        <!-- MAIN WORKSPACE -->
        <div class="workspace" id="workspace-container">
            <div id="collage-area">
                <!-- Frames injected here -->
            </div>
        </div>

        <!-- RIGHT SIDEBAR: Controls -->
        <div class="sidebar right">
            <h3>Canvas Settings</h3>
            <div class="control-group">
                <label>Aspect Ratio
                    <select id="aspect-select" onchange="app.setAspectRatio(this.value)">
                        <option value="1:1">1:1 (Square)</option>
                        <option value="4:3">4:3</option>
                        <option value="3:4">3:4</option>
                        <option value="16:9">16:9</option>
                        <option value="9:16">9:16 (Story)</option>
                        <option value="1.414">A4 (Portrait)</option>
                    </select>
                </label>
                <label>Background <input type="color" id="bg-color" value="#ffffff" onchange="app.updateCanvasStyle('bg', this.value)"></label>
                <label>Gap <span id="val-gap">0</span></label>
                <input type="range" min="0" max="50" value="0" oninput="app.updateCanvasStyle('gap', this.value)">
                <label>Padding <span id="val-pad">0</span></label>
                <input type="range" min="0" max="100" value="0" oninput="app.updateCanvasStyle('padding', this.value)">
            </div>

            <div id="frame-controls" style="opacity:0.5; pointer-events:none;">
                <h3>Selected Frame</h3>
                <div class="control-group">
                    <label>Border Width <span id="val-bw">0</span></label>
                    <input type="range" min="0" max="20" value="0" oninput="app.updateFrameStyle('borderWidth', this.value)">
                    
                    <label>Corner Radius <span id="val-br">0</span></label>
                    <input type="range" min="0" max="50" value="0" oninput="app.updateFrameStyle('borderRadius', this.value)">
                    
                    <label>Border Color <input type="color" id="border-color" value="#000000" onchange="app.updateFrameStyle('borderColor', this.value)"></label>
                </div>

                <h3>Image Transform</h3>
                <div class="control-group">
                    <label>Zoom <span id="val-zoom">100%</span></label>
                    <input type="range" min="0.1" max="3" step="0.1" value="1" id="inp-zoom" oninput="app.transformImage('zoom', this.value)">
                    
                    <label>Rotation <span id="val-rot">0°</span></label>
                    <input type="range" min="-180" max="180" step="90" value="0" id="inp-rot" oninput="app.transformImage('rotate', this.value)">
                    
                    <div class="btn-group" style="margin-top:5px;">
                        <button onclick="app.fitImage()" style="flex:1">Fit</button>
                        <button onclick="app.removeImage()" style="flex:1">Clear</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-top:auto; padding: 1rem;">
                <button onclick="app.resetProject()" style="width:100%; border-color: #ef4444; color:#ef4444;">Reset Project</button>
            </div>
        </div>
    </div>

    <div id="toast">Message</div>

<script>
/**
 * Collage Studio Logic
 * No external dependencies.
 */

const TEMPLATES = {
    'grid-1': [{x:0,y:0,w:100,h:100}],
    'grid-2h': [{x:0,y:0,w:100,h:50}, {x:0,y:50,w:100,h:50}],
    'grid-2v': [{x:0,y:0,w:50,h:100}, {x:50,y:0,w:50,h:100}],
    'grid-3': [{x:0,y:0,w:50,h:100}, {x:50,y:0,w:50,h:50}, {x:50,y:50,w:50,h:50}],
    'grid-4': [{x:0,y:0,w:50,h:50}, {x:50,y:0,w:50,h:50}, {x:0,y:50,w:50,h:50}, {x:50,y:50,w:50,h:50}],
    'grid-4-strip': [{x:0,y:0,w:25,h:100}, {x:25,y:0,w:25,h:100}, {x:50,y:0,w:25,h:100}, {x:75,y:0,w:25,h:100}],
    'polaroid': [{x:10,y:10,w:80,h:65}],
    'grid-6': [
        {x:0,y:0,w:33.33,h:50}, {x:33.33,y:0,w:33.33,h:50}, {x:66.66,y:0,w:33.33,h:50},
        {x:0,y:50,w:33.33,h:50}, {x:33.33,y:50,w:33.33,h:50}, {x:66.66,y:50,w:33.33,h:50}
    ]
};

class CollageApp {
    constructor() {
        this.state = {
            canvas: { width: 800, height: 800, bg: '#ffffff', gap: 5, padding: 20, ratio: 1 },
            frames: [], // { id, x, y, w, h, styles: {}, image: { id, zoom, rot, panX, panY } }
            images: {}, // Map of ID -> DataURL
            selection: null // frameId
        };
        
        this.history = [];
        this.historyIndex = -1;
        this.isDragging = false;
        this.dragStart = { x:0, y:0 };
        this.initialPan = { x:0, y:0 };

        this.ui = {
            canvas: document.getElementById('collage-area'),
            tray: document.getElementById('photo-tray'),
            frameControls: document.getElementById('frame-controls')
        };

        this.init();
    }

    init() {
        // Load from storage or default
        const saved = localStorage.getItem('collage_project');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                this.state = data.state;
                // Clean up old images if needed
            } catch(e) { console.error("Save load error", e); }
        } else {
            this.loadTemplate('grid-4');
        }

        this.setupEventListeners();
        this.renderTemplatesUI();
        this.render();
    }

    pushHistory() {
        // remove future history
        if (this.historyIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyIndex + 1);
        }
        this.history.push(JSON.stringify(this.state));
        if (this.history.length > 20) this.history.shift();
        else this.historyIndex++;
        
        this.saveLocally();
    }

    undo() {
        if (this.historyIndex > 0) {
            this.historyIndex--;
            this.state = JSON.parse(this.history[this.historyIndex]);
            this.render();
        }
    }

    redo() {
        if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.state = JSON.parse(this.history[this.historyIndex]);
            this.render();
        }
    }

    saveLocally() {
        localStorage.setItem('collage_project', JSON.stringify({ state: this.state, ts: Date.now() }));
    }

    resetProject() {
        if(confirm("Clear everything?")) {
            this.state.images = {};
            this.loadTemplate('grid-4');
            this.state.canvas.bg = '#ffffff';
            this.render();
            this.pushHistory();
        }
    }

    setupEventListeners() {
        // File Import
        const dz = document.getElementById('drop-zone');
        const fi = document.getElementById('file-input');
        
        dz.onclick = () => fi.click();
        fi.onchange = (e) => this.handleFiles(e.target.files);
        
        document.body.ondragover = (e) => e.preventDefault();
        document.body.ondrop = (e) => {
            e.preventDefault();
            this.handleFiles(e.dataTransfer.files);
        };

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); this.redo(); }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (this.state.selection !== null) this.removeImage();
            }
        });

        // Workspace Interaction (Panning Image)
        const ws = this.ui.canvas;
        ws.addEventListener('pointerdown', this.onPointerDown.bind(this));
        document.addEventListener('pointermove', this.onPointerMove.bind(this));
        document.addEventListener('pointerup', this.onPointerUp.bind(this));
        ws.addEventListener('wheel', this.onWheel.bind(this), {passive: false});

        // Dragging thumbnail
        this.ui.tray.addEventListener('dragstart', (e) => {
            if (e.target.dataset.imgId) {
                e.dataTransfer.setData('text/plain', e.target.dataset.imgId);
            }
        });

        // Dragging over frames
        this.ui.canvas.addEventListener('dragover', (e) => e.preventDefault());
        this.ui.canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const imgId = e.dataTransfer.getData('text/plain');
            // Find frame under cursor
            const rect = this.ui.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to %
            const px = (x / rect.width) * 100;
            const py = (y / rect.height) * 100;

            const frame = this.state.frames.find(f => 
                px >= f.x && px <= f.x + f.w &&
                py >= f.y && py <= f.y + f.h
            );

            if (frame && imgId) {
                this.pushHistory();
                frame.image = { 
                    id: imgId, zoom: 1, rot: 0, panX: 0, panY: 0 
                };
                this.selectFrame(frame.id);
                this.render();
            }
        });
    }

    /* --- Logic: Inputs --- */

    async handleFiles(files) {
        for (let file of files) {
            if (!file.type.startsWith('image/')) continue;
            
            const bitmap = await createImageBitmap(file);
            // Downscale logic
            const maxDim = 1600; 
            let w = bitmap.width, h = bitmap.height;
            if (w > maxDim || h > maxDim) {
                const scale = maxDim / Math.max(w, h);
                w *= scale; h *= scale;
            }

            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(bitmap, 0, 0, w, h);
            
            const id = 'img_' + Date.now() + Math.random().toString(36).substr(2, 5);
            const url = cvs.toDataURL('image/jpeg', 0.85); // Compress for storage
            
            this.state.images[id] = url;
            this.renderTray();
            
            // Auto-fill first empty frame
            const emptyFrame = this.state.frames.find(f => !f.image);
            if (emptyFrame) {
                emptyFrame.image = { id, zoom: 1, rot: 0, panX: 0, panY: 0 };
                this.render();
            }
        }
        this.pushHistory();
    }

    renderTray() {
        this.ui.tray.innerHTML = '';
        Object.entries(this.state.images).forEach(([id, url]) => {
            const img = document.createElement('img');
            img.src = url;
            img.className = 'thumb';
            img.draggable = true;
            img.dataset.imgId = id;
            img.onclick = () => {
                // If frame selected, fill it
                if (this.state.selection !== null) {
                    const f = this.state.frames.find(x => x.id === this.state.selection);
                    if(f) {
                        this.pushHistory();
                        f.image = { id, zoom: 1, rot: 0, panX: 0, panY: 0 };
                        this.render();
                        this.updateControlsUI(f);
                    }
                }
            };
            this.ui.tray.appendChild(img);
        });
    }

    loadTemplate(key) {
        this.pushHistory();
        const tpl = TEMPLATES[key];
        // Preserve existing images if possible?
        // Simple strategy: Collect images, redistribute.
        const existingImages = this.state.frames.map(f => f.image).filter(i => i);
        
        this.state.frames = tpl.map((box, i) => ({
            id: i,
            x: box.x, y: box.y, w: box.w, h: box.h,
            styles: { bw: 0, bc: '#000000', br: 0 },
            image: existingImages[i] || null
        }));
        this.state.selection = null;
        this.render();
    }

    /* --- Logic: Rendering --- */

    renderTemplatesUI() {
        const list = document.getElementById('template-list');
        Object.keys(TEMPLATES).forEach(k => {
            const div = document.createElement('div');
            div.className = 'template-item';
            div.onclick = () => this.loadTemplate(k);
            
            // Mini SVG preview
            let svg = `<svg viewBox="0 0 100 100">`;
            TEMPLATES[k].forEach(r => {
                svg += `<rect x="${r.x}" y="${r.y}" width="${r.w}" height="${r.h}" fill="#555" stroke="#333" stroke-width="1"/>`;
            });
            svg += `</svg>`;
            div.innerHTML = svg;
            list.appendChild(div);
        });
    }

    render() {
        const c = this.state.canvas;
        const root = this.ui.canvas;
        
        // Canvas Dimensions
        const maxDisplayH = document.getElementById('workspace-container').clientHeight - 40;
        const maxDisplayW = document.getElementById('workspace-container').clientWidth - 40;
        
        // Calculate aspect ratio
        let ratio = 1;
        if (c.ratio === '1:1') ratio = 1;
        else if (c.ratio === '4:3') ratio = 4/3;
        else if (c.ratio === '3:4') ratio = 3/4;
        else if (c.ratio === '16:9') ratio = 16/9;
        else if (c.ratio === '9:16') ratio = 9/16;
        else ratio = parseFloat(c.ratio);

        let finalH = maxDisplayH;
        let finalW = finalH * ratio;

        if (finalW > maxDisplayW) {
            finalW = maxDisplayW;
            finalH = finalW / ratio;
        }

        root.style.width = finalW + 'px';
        root.style.height = finalH + 'px';
        root.style.backgroundColor = c.bg;
        
        // Clear Frames
        root.innerHTML = '';

        // Draw Frames
        this.state.frames.forEach(f => {
            const div = document.createElement('div');
            div.className = 'frame';
            if (this.state.selection === f.id) div.classList.add('selected');
            
            // Position (Applying Global Gap/Padding)
            // Logic: The canvas has padding P. Inside that, grid with gap G.
            // Percentages need to be mapped to available area.
            
            const pad = parseInt(c.padding);
            const gap = parseInt(c.gap);
            
            // Available width/height inside padding
            const availW = finalW - (pad * 2);
            const availH = finalH - (pad * 2);
            
            // To handle gap correctly with percentages is tricky in pure CSS % without flex/grid.
            // We approximate: reduce width by gap/2 on sides. 
            // Better: use calc. 
            // f.x is %, f.w is %.
            
            div.style.left = `calc(${pad}px + ${f.x}% + ${f.x > 0 ? gap/2 : 0}px)`;
            div.style.top = `calc(${pad}px + ${f.y}% + ${f.y > 0 ? gap/2 : 0}px)`;
            div.style.width = `calc(${f.w}% * ${availW/finalW} - ${gap}px + ${gap * (f.w/100)}px)`; // Simple approximation
            // Precise logic:
            // width = (percent/100 * availW) - (isEdge ? 0 : gap) -- too complex for simple model.
            // We will do a simpler calc:
            // Pixel coordinates:
            const pxX = pad + (f.x/100 * availW);
            const pxY = pad + (f.y/100 * availH);
            const pxW = (f.w/100 * availW);
            const pxH = (f.h/100 * availH);
            
            // Adjust for gaps. If not touching edge, shrink.
            // This is a simplified "gap" logic (just shrinks everything)
            const gapAdj = gap / 2;
            
            div.style.left = (pxX + gapAdj) + 'px';
            div.style.top = (pxY + gapAdj) + 'px';
            div.style.width = (pxW - gap) + 'px';
            div.style.height = (pxH - gap) + 'px';

            // Styles
            div.style.border = `${f.styles.bw}px solid ${f.styles.bc}`;
            div.style.borderRadius = `${f.styles.br}px`;

            // Image
            if (f.image && this.state.images[f.image.id]) {
                const img = document.createElement('img');
                img.src = this.state.images[f.image.id];
                // Transform
                // Pan is in pixels relative to frame center. Zoom is multiplier.
                // We must handle rotation.
                // Note: panX/Y are relative to non-rotated axis for UX consistency.
                img.style.transform = `translate(-50%, -50%) translate(${f.image.panX}px, ${f.image.panY}px) scale(${f.image.zoom}) rotate(${f.image.rot}deg)`;
                
                // We need to ensure the image covers the area initially.
                // Since we don't know image aspect ratio easily without loading it, 
                // we rely on CSS min-width/height or user manual adjustment.
                // Default: cover logic done via JS? For now, user adjusts.
                // Helper: setting min-width/height to frame size ensures no gaps if zoom=1
                
                // Actually, let's just make it large enough to start
                if(f.image.rot % 180 === 0) {
                     img.style.minWidth = '100%';
                     img.style.minHeight = '100%';
                } else {
                     // If rotated 90, width becomes height
                     img.style.minWidth = (pxH - gap) + 'px';
                }

                div.appendChild(img);
            } else {
                div.innerHTML = '<div class="empty-msg">+</div>';
            }

            // Events
            div.onpointerdown = (e) => {
                e.stopPropagation();
                this.selectFrame(f.id);
                // Setup drag/pan
                if (f.image) {
                    this.isDragging = true;
                    this.dragStart = { x: e.clientX, y: e.clientY };
                    this.initialPan = { x: f.image.panX, y: f.image.panY };
                }
            };

            root.appendChild(div);
        });

        // Update UI Controls
        const selFrame = this.state.frames.find(f => f.id === this.state.selection);
        this.updateControlsUI(selFrame);
    }

    updateControlsUI(frame) {
        const pan = this.ui.frameControls;
        if (!frame) {
            pan.style.opacity = '0.5';
            pan.style.pointerEvents = 'none';
            return;
        }
        pan.style.opacity = '1';
        pan.style.pointerEvents = 'auto';

        // Update sliders without triggering events
        const set = (id, val) => {
            const el = document.getElementById(id);
            if(el) el.value = val;
        };
        const setTxt = (id, txt) => document.getElementById(id).innerText = txt;

        set('val-bw', frame.styles.bw);
        setTxt('val-bw', frame.styles.bw);
        // Find input
        pan.querySelector('[oninput*="borderWidth"]').value = frame.styles.bw;
        pan.querySelector('[oninput*="borderRadius"]').value = frame.styles.br;
        document.getElementById('border-color').value = frame.styles.bc;

        if (frame.image) {
            document.getElementById('inp-zoom').value = frame.image.zoom;
            setTxt('val-zoom', Math.round(frame.image.zoom*100)+'%');
            document.getElementById('inp-rot').value = frame.image.rot;
            setTxt('val-rot', frame.image.rot + '°');
        }
    }

    selectFrame(id) {
        this.state.selection = id;
        this.render();
    }

    /* --- Logic: Updates --- */

    updateCanvasStyle(prop, val) {
        this.pushHistory();
        if (prop === 'bg') this.state.canvas.bg = val;
        if (prop === 'gap') { this.state.canvas.gap = val; document.getElementById('val-gap').innerText = val; }
        if (prop === 'padding') { this.state.canvas.padding = val; document.getElementById('val-pad').innerText = val; }
        this.render();
    }

    setAspectRatio(val) {
        this.pushHistory();
        this.state.canvas.ratio = val;
        this.render();
    }

    updateFrameStyle(prop, val) {
        if (this.state.selection === null) return;
        // Don't push history on every drag step, maybe debounce? 
        // For simplicity in this demo, we modify state directly and push history on mouseup (not impl here) or rely on user discipline.
        // Actually, let's just push history if it's a change.
        
        const f = this.state.frames.find(x => x.id === this.state.selection);
        if (prop === 'borderWidth') { f.styles.bw = val; document.getElementById('val-bw').innerText = val; }
        if (prop === 'borderRadius') { f.styles.br = val; document.getElementById('val-br').innerText = val; }
        if (prop === 'borderColor') { f.styles.bc = val; }
        this.render();
    }

    transformImage(prop, val) {
        if (this.state.selection === null) return;
        const f = this.state.frames.find(x => x.id === this.state.selection);
        if (!f.image) return;

        if (prop === 'zoom') { f.image.zoom = parseFloat(val); }
        if (prop === 'rotate') { f.image.rot = parseInt(val); }
        this.render();
    }

    fitImage() {
        if (this.state.selection === null) return;
        const f = this.state.frames.find(x => x.id === this.state.selection);
        if (f.image) {
            this.pushHistory();
            f.image.zoom = 1;
            f.image.panX = 0;
            f.image.panY = 0;
            f.image.rot = 0;
            this.render();
        }
    }

    removeImage() {
        if (this.state.selection === null) return;
        const f = this.state.frames.find(x => x.id === this.state.selection);
        this.pushHistory();
        f.image = null;
        this.render();
    }

    /* --- Interaction: Drag/Pan --- */
    
    onPointerDown(e) {
        // Handled in frame div, but if we need global handling
    }

    onPointerMove(e) {
        if (this.isDragging && this.state.selection !== null) {
            const f = this.state.frames.find(x => x.id === this.state.selection);
            if (f && f.image) {
                const dx = e.clientX - this.dragStart.x;
                const dy = e.clientY - this.dragStart.y;
                
                // We must account for rotation? 
                // Simple implementation: Pan is always X/Y of screen, applied to translation.
                // If the image is rotated, 'translate' axes rotate with it.
                // To pan intuitively (screen space), we might need trigonometry if we applied rotate BEFORE translate.
                // Our CSS: translate(-50,-50) translate(panX, panY) rotate(deg).
                // Here panX/panY align with screen X/Y (mostly).
                
                f.image.panX = this.initialPan.x + dx;
                f.image.panY = this.initialPan.y + dy;
                
                // Optimization: Don't full render, just update DOM element
                const el = this.ui.canvas.querySelector('.frame.selected img');
                if (el) {
                    el.style.transform = `translate(-50%, -50%) translate(${f.image.panX}px, ${f.image.panY}px) scale(${f.image.zoom}) rotate(${f.image.rot}deg)`;
                }
            }
        }
    }

    onPointerUp(e) {
        if (this.isDragging) {
            this.isDragging = false;
            this.saveLocally(); // Save after drag end
        }
    }

    onWheel(e) {
        if (this.state.selection !== null) {
            const f = this.state.frames.find(x => x.id === this.state.selection);
            if (f && f.image) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                let newZoom = Math.max(0.1, Math.min(3.0, parseFloat(f.image.zoom) + delta));
                f.image.zoom = newZoom;
                this.render();
                // Update slider UI
                document.getElementById('inp-zoom').value = newZoom;
                document.getElementById('val-zoom').innerText = Math.round(newZoom*100) + '%';
            }
        }
    }

    /* --- Export System --- */

    async exportCollage(returnBlob = false) {
        this.showToast("Rendering...");
        
        const scale = 2; // Output resolution multiplier (High Quality)
        const c = this.state.canvas;
        
        // Determine pixel size based on DOM workspace ratio logic, but higher res
        let baseW = 1200; // Base export width
        let ratio = 1;
        // ... (Ratio logic duplicated from render, simplified)
        if (c.ratio === '4:3') ratio = 4/3;
        else if (c.ratio === '3:4') ratio = 3/4;
        else if (c.ratio === '16:9') ratio = 16/9;
        else if (c.ratio === '9:16') ratio = 9/16;
        else if (c.ratio === '1.414') ratio = 1/1.414; // Portrait A4
        else if (c.ratio === '1:1') ratio = 1;
        else ratio = parseFloat(c.ratio);

        const width = baseW * scale;
        const height = (baseW / ratio) * scale;

        const cvs = document.createElement('canvas');
        cvs.width = width;
        cvs.height = height;
        const ctx = cvs.getContext('2d');

        // Background
        ctx.fillStyle = c.bg;
        ctx.fillRect(0, 0, width, height);

        // Calc metrics
        const pad = parseInt(c.padding) * (width / this.ui.canvas.offsetWidth); 
        const gap = parseInt(c.gap) * (width / this.ui.canvas.offsetWidth);
        
        const availW = width - (pad * 2);
        const availH = height - (pad * 2);

        // Draw Frames
        for (let f of this.state.frames) {
            // Calculate Position (Same logic as DOM but scaled)
            const pxX = pad + (f.x/100 * availW);
            const pxY = pad + (f.y/100 * availH);
            const pxW = (f.w/100 * availW);
            const pxH = (f.h/100 * availH);
            
            const gapAdj = gap / 2;
            
            let x = pxX + gapAdj;
            let y = pxY + gapAdj;
            let w = pxW - gap;
            let h = pxH - gap;
            
            const radius = parseInt(f.styles.br) * (width / this.ui.canvas.offsetWidth);
            const borderW = parseInt(f.styles.bw) * (width / this.ui.canvas.offsetWidth);

            // Clip Path (Rounded Rect)
            ctx.save();
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, radius);
            ctx.clip();

            // Background of frame
            ctx.fillStyle = "#eee";
            ctx.fillRect(x, y, w, h);

            // Image
            if (f.image && this.state.images[f.image.id]) {
                const imgEl = new Image();
                imgEl.src = this.state.images[f.image.id];
                await new Promise(r => { if(imgEl.complete) r(); else imgEl.onload = r; });

                const iW = imgEl.naturalWidth;
                const iH = imgEl.naturalHeight;

                ctx.save();
                
                // Transform Origin: Center of frame
                ctx.translate(x + w/2, y + h/2);
                
                // Pan (Scaled)
                // Pan in State is screen pixels. We need to scale that to canvas size.
                const scaleFactor = width / this.ui.canvas.offsetWidth;
                ctx.translate(f.image.panX * scaleFactor, f.image.panY * scaleFactor);
                
                ctx.rotate(f.image.rot * Math.PI / 180);
                ctx.scale(f.image.zoom, f.image.zoom);
                
                // Draw Image centered
                ctx.drawImage(imgEl, -iW/2, -iH/2);
                
                ctx.restore();
            }

            ctx.restore(); // Remove Clip

            // Draw Border
            if (borderW > 0) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                ctx.lineWidth = borderW;
                ctx.strokeStyle = f.styles.bc;
                ctx.stroke();
            }
        }

        if (returnBlob) {
            return new Promise(resolve => cvs.toBlob(resolve, 'image/png'));
        }

        // Download
        const link = document.createElement('a');
        link.download = 'collage-' + Date.now() + '.png';
        link.href = cvs.toDataURL();
        link.click();
        this.showToast("Downloaded!");
    }

    async copyToClipboard() {
        try {
            const blob = await this.exportCollage(true);
            await navigator.clipboard.write([
                new ClipboardItem({ 'image/png': blob })
            ]);
            this.showToast("Copied to Clipboard!");
        } catch (err) {
            console.error(err);
            this.showToast("Clipboard not supported, downloading instead.");
            this.exportCollage();
        }
    }

    showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 3000);
    }
}

// Polyfill for roundRect if needed (Chrome/Firefox have it, Safari 16+)
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };
}

const app = new CollageApp();

</script>
</body>
</html>
